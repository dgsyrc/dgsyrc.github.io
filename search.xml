<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷题解 CF991B 【Getting an A】]]></title>
    <url>%2F2020%2F04%2F12%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20CF991B%20%E3%80%90Getting%20an%20A%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意简述：给你几门测试的成绩，问你最少要重测几门才能使平均成绩四舍五入为5分 解题思路：其实就是贪心的思想，而且要用到万恶的$sort$（图个方便） 根据我们的生活经验，很容易就能想到先把差的重测 又因为题目中有最少的字眼，故我们可以假设重测后就能满分（实际上几乎不可能，但是我们要作为理想状态考虑） 是不是有人看到四舍五入就头痛了 这里提供一种简便的方法： 所有数据扩大十倍，这样原来的十分位就变成了个位 然后你就可以直接处理了 我的代码没有用整除，取而代之的是乘法（这是有好处的） 显然$sum/n \geq 45$和$n*45 \leq sum$等价 代码实现： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,src[110],sum;int main()&#123; scanf("%d",&amp;n); for(int a=1;a&lt;=n;++a) &#123; scanf("%d",&amp;src[a]); src[a]=src[a]*10;//扩大十倍 sum=sum+src[a];//累加记录总分 &#125; sort(src+1,src+n+1); int cot=0; while(n*45&gt;=sum)//判断是否满足题目条件 &#123; cot++;//统计重测次数 sum=sum-src[cot]+50;//把当前最低分改为满分重新计入总分 &#125; printf("%d\n",cot); return 0;&#125; 题目详见:https://www.luogu.com.cn/problem/CF991B]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 UVA756 【Biorhythms】]]></title>
    <url>%2F2020%2F04%2F05%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20UVA756%20%E3%80%90Biorhythms%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意一个人体力、情感、智力出现峰值的周期分别为23、28、33天，现在给出三者上一次出现峰值的日期$p,e,i$和现在的日期$d$，问经过几天三个峰值会出现在同一天。 思路首先这一看就是中国剩余定理的模板题， 如果不知道中国剩余定理建议先学习再做本题，这样就会发现这题是非常简单的。 由题意和中国剩余定理可得以下方程组： $$ \begin{cases} x≡p(mod\ 23) \ (1) \\ x≡e(mod\ 28) \ (2)\\ x≡i(mod\ 33) \ (3)\end{cases} $$ 其中，该方程组可以化为以下形式： $$(1) \begin{cases} x_1≡1(mod\ 23) \\ x_1≡0(mod\ 28) \\ x_1≡0(mod\ 33) \end{cases} $$ $$(2) \begin{cases} x_2≡0(mod\ 23) \\ x_2≡1(mod\ 28) \\ x_2≡0(mod\ 33) \end{cases} $$ $$(3) \begin{cases} x_3≡0(mod\ 23) \\ x_3≡0(mod\ 28) \\ x_3≡1(mod\ 33) \end{cases} $$ 解以上方程组，有： $$ \begin{cases} x_1=5544 \\ x_2=14421 \\ x_3=1288 \end{cases} $$ 由中国剩余定理有： $ lcm(23,28,33)=21252 $ $ ans+d≡p * x_1+e * x_2+i * x_3(mod \ 21252) $ 化简得： $ ans=(p * x_1+e * x_2+i * x_3-d+21252)\ mod\ 21252 $ 即： $ ans=(p * 5544+e * 14421+i * 1288-d+21252)\ mod\ 21252 $ 这样我们就得到了本题的通解。 但是有个特殊情况，当$ans=0$时要输出$21252$，因为你要求的是下一次三者同一天。 Q：为什么通解中要$+21252$ A：因为题目中不能保证$d$一定小于$p$、$e$、$i$，所以为了避免$ans$变成负数，所以要先$+21252$再取模 代码实现12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=21252;//lcm(23,28,33)int p,e,i,d,cot;int main()&#123; scanf("%d%d%d%d",&amp;p,&amp;e,&amp;i,&amp;d); while(p+e+i+d!=-4) &#123; cot++; int ans=(5544*p+14421*e+1288*i-d+maxn)%maxn;//通解 if(ans==0)//特判 &#123; ans=maxn; &#125; printf("Case %d: the next triple peak occurs in %d days.\n",cot,ans); scanf("%d%d%d%d",&amp;p,&amp;e,&amp;i,&amp;d); &#125; return 0;&#125; 题目详见:https://www.luogu.com.cn/problem/UVA756]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 UVA11039 【Building designing】]]></title>
    <url>%2F2020%2F03%2F26%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20UVA11039%20%E3%80%90Building%20designing%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意简述：给你一个长度n的序列，选出一个子序列排列出一正一负交替并且绝对值递增使得子序列长度最长，求它的长度。 思路：首先题目数据量不大，完全可以用扫描的方法过。 首先对得到的序列进行排序（当然要用到万恶的$sort$），将其按绝对值大小从小到大排。 随后，选定绝对值最小的数作为开头，并用一个变量$last$记录。 接着从2开始扫到n： 对于每一个数，若$last&lt;0$且当前数大于0，更新$last$为当前数并将子序列长度+1； 若$last&gt;0$且当前数小于0，更新$last$为当前数并将子序列长度+1； 以上步骤相当于做了一个一正一负逐个选择的过程。 时间复杂度$O(n \ log\ n)$。 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int T,n,list[500010],last,ans;inline int c_abs(int k)&#123; return (k&gt;0)?k:-k;&#125;bool cmp(int x,int y)&#123; return c_abs(x)&lt;c_abs(y);&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int a=1;a&lt;=n;++a) &#123; scanf("%d",&amp;list[a]); &#125; sort(list+1,list+n+1,cmp); last=list[1]; ans=1; for(int a=2;a&lt;=n;a++) &#123; if(last&lt;0&amp;&amp;list[a]&gt;0) &#123; last=list[a]; ans++; continue; &#125; if(last&gt;0&amp;&amp;list[a]&lt;0) &#123; last=list[a]; ans++; continue; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; 题目详见:https://www.luogu.com.cn/problem/UVA11039]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 CF23B 【Party】]]></title>
    <url>%2F2020%2F03%2F25%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20CF23B%20%E3%80%90Party%E3%80%91%2F</url>
    <content type="text"><![CDATA[解题思路：首先这一看就是数学题【应该让雾之湖的Cirno来做(这题明显就很⑨$^*$)】。 *:⑨就是baka的意思。 其次，题目要求你在这$n$个人中找到一种关系图使得剩下的人最多，输出剩下的人数。 题目所说的朋友个数是指在场的，走了的就要减去。 关系是相互的。 （题目翻译有点误导人，没说明白） 当然要先画图模拟找规律啦！ 规律：一个人：一个人就不画图了，明摆着当扫到0个朋友的人离开时他就要走。 两个人：同上，图可以脑补，因为只存在两种关系（要么两个人是朋友，要么不是）。 同样，没有人可以剩下。 三个人：咯，你们要的图： 如图所设的关系： 当0个朋友的人要走时，没有人要走； 当1个朋友的人要走时，2、3要走； 当2个朋友的人要走时，没有人要走；（此时1的朋友个数为0，巧妙地绕过了扫描） 这样我们就剩下了1个人。 四个人： 如图所设的关系： 当0个朋友的人要走时，没有人要走； 当1个朋友的人要走时，没有人要走； 当2个朋友的人要走时，1、3要走； 当3个朋友的人要走时，没有人要走；（此时2和4的朋友个数为1，巧妙地绕过了扫描） 这样我们就剩下了2个人。 n个人：（4人以后的情况就不画了，占的版面太多） 根据上述方法继续推，不难发现剩下的人数总是$n-2$。 所以我们就有以下关系（设答案为$ans$）： $$ ans= \begin{cases} 0, &amp; 0 \leq n &lt; 2 \\ n-2, &amp; n \geq 2 \end{cases} $$ 所以我们就有如下代码： 12345678910111213141516#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int T,n;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); (n&lt;2)?printf("0\n"):printf("%d\n",n-2);//这里就不用解释了吧 &#125; return 0;&#125; 题目详见:https://www.luogu.com.cn/problem/CF23B]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 CF810A 【Straight 《A》】]]></title>
    <url>%2F2020%2F03%2F25%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20CF810A%20%E3%80%90Straight%20%E3%80%8AA%E3%80%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题的思路： 简单循环枚举即可，因为数据量小。 主要的问题在于四舍五入。 枚举虽然看起来偷懒，但是在赛场上在数据以及时间空间限制允许的情况下，总比你跑数论好（省做题时间）。 我们知道1.5、1.6、1.7、1.8、1.9、2.0、2.1、2.2、2.3、2.4四舍五入都为2，我们可以将其扩大十倍，即15、16、17、18、19、20、21、22、23、24。 由于C++中的/是整除，这样我们就可以判断当扩大后的数被整除后，与k*10的误差范围为-5~4时即可判断相等。 至于小数点后面第二位及以后的数其实对此影响不大，因为扩大十倍后15.00001在整除中还是15,24.999999在整除中还是24。 代码如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,k,num[110],cot=0,sum=0;int main()&#123; scanf("%d%d",&amp;n,&amp;k); k=k*10;//扩大十倍 for(int a=1;a&lt;=n;a++) &#123; scanf("%d",&amp;num[a]); sum=sum+num[a]*10;//扩大十倍 &#125; while(true)//无限循环判断 &#123; if((sum+cot*k)/(n+cot)&gt;=k-5&amp;&amp;(sum+cot*k)/(n+cot)&lt;k+5) &#123; printf("%d\n",cot); break; &#125; cot++;//累加k的个数 &#125; return 0;&#125; 题目详见:https://www.luogu.com.cn/problem/CF810A]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI模板题单]]></title>
    <url>%2F2020%2F03%2F22%2FOI%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8D%95%2F</url>
    <content type="text"><![CDATA[快速排序：P1177 【模板】快速排序 快速幂：P1226 【模板】快速幂||取余运算 最小生成树：P3366 【模板】最小生成树 P2330 [SCOI2005]繁忙的都市 P1546 [USACO3.1]最短网络 Agri-Net P2872 [USACO07DEC]Building Roads S P1547 [USACO05MAR]Out of Hay S P2820 局域网 P1991 无线通讯网 P1265 公路修建 P2212 [USACO14MAR]Watering the Fields S P1195 口袋的天空 并查集：P3367 【模板】并查集 P1551 亲戚 P3958 奶酪 P1455 搭配购买 P2078 朋友 P1111 修复公路 P1536 村村通 P2256 一中校运会之百米跑 P1892 [BOI2003]团伙 P2835 刻录光盘 P1197 [JSOI2008]星球大战 P2814 家谱 最短路：P3371 【模板】单源最短路径（弱化版） P4779 【模板】单源最短路径（标准版） P2910 [USACO08OPEN]Clear And Present Danger S P1359 租用游艇 P2984 [USACO10FEB]Chocolate Giving S P2935 [USACO09JAN]Best Spot S P1339 [USACO09OCT]Heat Wave G P1744 采购特价商品 P2299 Mzc和体委的争夺战 P1821 [USACO07FEB]Silver Cow Party S P1364 医院设置 P1529 [USACO2.4]回家 Bessie Come Home P3905 道路重建 P1629 邮递员送信 P2951 [USACO09OPEN]Hide and Seek S P2888 [USACO07NOV]Cow Hurdles S P2419 [USACO08JAN]Cow Contest S P1144 最短路计数 P1828 [USACO3.2]香甜的黄油 Sweet Butter P1576 最小花费 P2850 [USACO06DEC]Wormholes G P1931 套利 P2136 拉近距离 P1875 佳佳的魔法药水 P2384 最短路 P1119 灾后重建 素数筛：P3383 【模板】线性筛素数 负环：P3385 【模板】负环 树状数组：P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P5057 [CQOI2006]简单题 P2068 统计和 尺取法：UVA1121 【模板】尺取法（Subsequence） SP2176 【模板】尺取法进阶（FSEATS - Finding Seats） 扩展欧几里德：P1082 【模板】同余方程 P1516 青蛙的约会 中国剩余定理：UVA756 Biorhythms]]></content>
      <tags>
        <tag>OI</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建一个属于自己的Minecraft服务器]]></title>
    <url>%2F2020%2F03%2F14%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[相信许多MC玩家想要在自己家中和别人联机开黑 但是如果跨网了，那怎么联机呢？ 经过我3个小时仔细研究，总算成功了。 注： 1.本文是以官方服务端的1.14.2版本为例，后文部分配置项名称不一定与读者的实际名称相同，但是肯定是相似的，请自行变通。 2.本文暂无插件，mod配置教程 以下就是教程： 下载服务端：注：本文使用的是官方服务端 根据你的需要的版本进行选择 下载地址 在网页中选择你要Download的版本，进去后会有Server Jar和Client Jar两个选项 选择Server Jar下载 启动服务端：启动：将下载好的服务端Server.jar放在你要开服的目录下，建议为英文目录（防止程序出错） 新建一个文本文档Start.txt，复制以下代码进去 1234567@ECHO OFF@echo 正在开启中。。。start jre8/bin/java.exe -Xms1200M -Xmx1200M -jar server.jar@echo 已执行启动指令@echo 当弹出Java控制台时可以关闭该窗口!pause 其中-Xms1200M和-Xmx1200M分别为最大分配内存和最小分配内存，M即单位MB，当然也可以把单位改成G即单位GB。 jre8/bin/java.exe是你的java安装目录，笔者是独立放了一个java8在服务器文件夹内，如果您要使用自己电脑上默认安装的java，请依照实际填写，示例start &quot;&quot; &quot;C:/Program Files/Java/jre1.8.0_241/bin/java.exe&quot; -Xms1200M -Xmx1200M -jar server.jar 然后将Start.txt重命名为Start.bat,双击运行。 （如果你的电脑默认不显示已知文件的后缀，请到组织-文件夹和搜索选项-查看中把隐藏已知文件类型的扩展名的勾去掉并点击应用） 同意协议：第一次启动服务端时会马上闪退，同时你的文件夹下会生成eula.txt。 这时你需要打开eula.txt，并将其中的false改为true。 注意不要打错字，是true而不是ture。 注意事项：如果你已经准备好你的服务器地图，那么下面的配置中有关世界生成的配置项可以忽略，但是游戏模式方面的配置还是要按需修改，建议往下仔细阅读。 服务器配置：以下配置均为服务器目录下server.properties内的配置。 只介绍用处较大的，用处较小的就自己到Minecraft Wiki看吧。 强制更改玩家游戏模式：1force-gamemode=false false：玩家将以上次退出服务器时的游戏模式加入； true：强制玩家每次进入时为默认游戏模式; （默认游戏模式详见后文） 地狱生成：1allow-nether=true false：没有地狱； true：有地狱; 默认游戏模式：1gamemode=0 0：生存模式； 1：创造模式; 2：冒险模式； 3：旁观模式; 踢出挂机玩家：1player-idle-timeout=0 0：不踢出挂机玩家； 其它：单位为分钟，在达到该挂机时间时踢出该玩家; 难度：1difficulty=1 0：和平； 1：简单; 2：普通； 3：困难; 生成怪物：1spawn-monsters=true false：不刷怪（敌对）； true：刷怪（敌对）; PVP：1pvp=true false：玩家无法互相攻击； true：玩家可以互相攻击; 世界类型：1level-type=default default：标准； flat：平坦; largebiomes：巨型生物群系； 极限模式：就是死亡后变为旁观模式。 1hardcore=false false：关闭极限模式； true：开启极限模式; 命令方块：1enable-command-block=false false：禁用命令方块； true：启用命令方块; 玩家数量限制：1max-players=20 不解释，你懂的。 世界大小：1max-world-size=29999984 数字为世界的最大半径，单位为方块。 服务器端口：1server-port=25565 25565即服务器开放端口号，可以按需调整。 村民生成：1spawn-npcs=true false：不生成村民； true：生成村民; 世界名称：1level-name=world 默认是world，按需修改，如果是自己准备的地图，该项修改为你自己的地图名称。 可视距离：1view-distance=10 玩家可以看到的最远距离，单位为区块。 动物生成：1spawn-animals=true false：不生成动物； true：生成动物; 生成建筑：1generate-structures=true false：不生成建筑（地牢除外）； true：生成建筑（如村庄）; 方块放置高度：1max-build-height=256 顾名思义，不解释。 正版验证：1online-mode=true false：关闭正版验证（玩家不需要登录正版Minecraft账号）； true：开启正版验证（玩家需要登录正版Minecraft账号）; 注：这一点很重要，没正版一定要开false。 种子：1level-seed= 不解释，你懂的，留空则随机种子。 服务器信息：1motd=A Minecraft Server 就是那个显示在服务器名称下的信息，可以修改。 地图配置：服务器生成：启动服务器即可，将会按照上面的配置生成。 自定义：将你的地图文件夹直接放在服务器目录下，名称请务必与上面的配置项一致。 做到这里，你已经可以尝试在本机上打开Minecraft进入服务器了。 服务器地址为本机局域网ip（192.168.?.?）:端口,:务必保证是英文的，中文的不行。 内网穿透：注册：在https://natapp.cn/上注册一个账号。 获取隧道：注意：可能会提示要先实名认证，请实名认证后继续操作。 登录后进去点击购买隧道（其实不要钱）。 选择免费的隧道，协议我选的是TCP,UDP我没试过行不行，端口填你上面配置的服务器端口。 本地配置：下载NATAPP客户端，是一个.exe。 打开客户端，复制该代码进去，不要按回车。 1natapp -authtoken= 接着去我的隧道中，点击配置进入，复制你的authtoken到客户端，回车登录。 接着你会看到如下界面，说明配置成功。 配置完成：把你的服务器地址及端口发给你的伙伴，他们就可以连进来了。 地址端口示例：server.natappfree.cc:45639 注：端口号每次启动NATAPP客户端都会变，请用客户端内显示的端口。 还是那句话，:必须是英文的。 赶紧试试吧！]]></content>
      <tags>
        <tag>教程</tag>
        <tag>我的世界</tag>
        <tag>Minecraft</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P3958 【奶酪】]]></title>
    <url>%2F2020%2F03%2F06%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P3958%20%E3%80%90%E5%A5%B6%E9%85%AA%E3%80%91%2F</url>
    <content type="text"><![CDATA[首先这道题要用到以下知识： 并查集、圆与圆的位置关系（可推广到球与球）、空间两点坐标公式 空间两点坐标公式体面给了，这里不讲。 先讲圆与圆的位置关系判定： 如图，从上到下，从左到右依次是：外离，外切，相交，内切，内含 设两圆圆心距离为$d(d&gt;0)$，半径为$r_1$、$r_2$ 则有以下关系： 外离：$d&gt;r_1+r_2$ 外切：$d=r_1+r_2$ 相交：$|r_1-r_2|&lt;d&lt;r_1+r_2$ 内切：$d=|r_1-r_2|$ 内含：$d&lt;|r_1-r_2|$ 此结论可以直接推广至球与球的位置关系。 对于本题，我们只需要考虑外离、相切、相交三种情况，内切和内含可略去（没有意义）。 题中默认$z$轴正方向向上，$x$轴、$y$轴随意（不影响） 我的思路是： 每个球各化为一点， 顶层底层各是一点， 若相切相交即为合并， 最后再验顶底同祖宗。 对于此题，除了用上外离、外切、相交的判定外，还有： 若$z-r&lt;=0$，则该球与底部相交/相切。 若$z+r&gt;=h$，则该球与顶部相交/相切。 贴代码，附解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 定义底层节点编号为0，顶层节点编号为n+1 */#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;int n,h,r,fa[1010],T;//fa存父节点int x[1010],y[1010],z[1010];//你懂得double dis(double xa,double ya,double za,double xb,double yb,double zb)//套公式&#123; return (double)(sqrt((double)(xa-xb)*(xa-xb)+(double)(ya-yb)*(ya-yb)+(double)(za-zb)*(za-zb)));&#125;int find(int s)//注意用了路径压缩&#123; int k=s,t; while(k!=fa[k]) &#123; k=fa[k]; &#125; while(s!=fa[s]) &#123; t=s; s=fa[s]; fa[t]=k; &#125; return k;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;n,&amp;h,&amp;r); for(int a=0;a&lt;=n+1;a++)//注意每次要初始化父节点为自己 &#123; fa[a]=a; &#125; for(int a=1;a&lt;=n;a++) &#123; scanf("%d%d%d",&amp;x[a],&amp;y[a],&amp;z[a]); if(z[a]-r&lt;=0)//底层合并 &#123; if(find(a)!=find(0)) &#123; fa[find(a)]=find(0); &#125; &#125; if(z[a]+r&gt;=h)//顶层合并 &#123; if(find(a)!=find(n+1)) &#123; fa[find(a)]=find(n+1); &#125; &#125; for(int b=1;b&lt;a;b++)//洞间合并 &#123; if(2*r&gt;=dis(x[a],y[a],z[a],x[b],y[b],z[b])) &#123; if(find(a)!=find(b)) &#123; fa[find(a)]=find(b); &#125; &#125; &#125; &#125; if(find(0)==find(n+1))//验顶层底层是否连通 &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; return 0;&#125; 题目详见:https://www.luogu.com.cn/problem/P3958]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假自学计划安排（Updated）]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%AF%92%E5%81%87%E8%87%AA%E5%AD%A6%E8%AE%A1%E5%88%92%E5%AE%89%E6%8E%92%EF%BC%88Updated%EF%BC%89%2F</url>
    <content type="text"><![CDATA[已延迟开学 61 天（UPD:2020-04-10） 计划与登记停止更新 前言：2020年是个神奇的一年， 这一年开头， 澳大利亚森林大火失控， 乌克兰客机坠毁， 英国脱欧， 新型冠状病毒广泛传播， 科比遇难， 横扫亚非的蝗灾， 频繁的地震， 美国股票连续4次熔断， 以及……最长的一次寒假， 近一个月没出过门。 总不能在家没事干吧…… Game？ 打久了有点无聊。 Study？ 好像有点用，是不是枯燥了点？ Music？ 总不能一直听吧…… 不如把三个揉在一起？ 那就试一下吧！ 计划（方便排版，Monday为一周第一天）：第一周（2.10~2.16）： 第二周（2.17~2.23）： 第三周（2.24~3.1）： 第四周（3.2~3.8）： 第五周（3.9~3.15）： 第六周（3.16~3.23）： Game:主要是颓音游，有时是Minecraft。 音游：osu!、Cytoid、Arcaea、Lanota 还有皇室战争…… Music：多着呢…… 就列举几个吧： 《Flower Dance》 《Luv Letter》 《Bad Apple!!》 《チルノのパーフェクトさんすう教室》 《Bloom of Youth》 《雲流れ》 《U.N.オーエンは彼女なのか?》 《不思議の国のアリス》 《輝く針の小人族 ～ Little Princess》 《Intro》 其他详见歌单 进度登记：第一周（2.10~2.16）： 第二周（2.17~2.23）： 第三周（2.24~3.1）： 第四周（3.2~3.8）： 第五周（3.9~3.15）： 第六周（3.16~3.22）： 补充：UPD:2020-02-24广东解除了一级响应，降至二级（看来快开学了） UPD:2020-02-25广东省教育厅发文3月2日起进行在线教育，不得返校，返校时间另定 UPD:2020-02-26学校允许学生申请回校拿资料，由班级学生代表和班主任将资料从班上带到门卫交给学生 UPD:2020-03-02正式线上开学 UPD:2020-03-22国外确诊超25w UPD:2020-04-09国外确诊超150w 广东省教育厅宣布全省高三、初三4月27日开学，其他年级、高校等5月11日后分批开学，幼儿园、托儿所原则上不开学]]></content>
      <tags>
        <tag>学习</tag>
        <tag>高中</tag>
        <tag>寒假</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念入坑ACG三周年]]></title>
    <url>%2F2020%2F02%2F06%2F%E7%BA%AA%E5%BF%B5%E5%85%A5%E5%9D%91ACG%E4%B8%89%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[本图在任何情况下都不允许转载，除博主书面允许外]]></content>
      <tags>
        <tag>动漫</tag>
        <tag>ACG</tag>
        <tag>周年</tag>
        <tag>纪念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS小技巧-提取线稿]]></title>
    <url>%2F2020%2F02%2F02%2FPS%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%8F%90%E5%8F%96%E7%BA%BF%E7%A8%BF%2F</url>
    <content type="text"><![CDATA[效果对比：原图： 效果图： 第一步：打开Photoshop，将你要提取线稿的图拉进来 第二步：复制该图层(ctrl+J) 第三步：在新图层中，点击图像-调整-去色 第四步：使用滤镜锐化 第五步：使用滤镜USM锐化，数量调整为37%左右，半径调整为1.0像素 第六步：复制该图层（ctrl+J） 第七步：在新图层中，点击图像-调整-反相 第八步：将图层修改为线性减淡（添加） 第九步：使用滤镜最小值，半径1~3像素（根据实际效果设置） 完成！]]></content>
      <tags>
        <tag>PS</tag>
        <tag>绘画</tag>
        <tag>动漫</tag>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[口技-东莞中学版]]></title>
    <url>%2F2020%2F01%2F17%2F%E5%8F%A3%E6%8A%80-%E4%B8%9C%E8%8E%9E%E4%B8%AD%E5%AD%A6%E7%89%88%2F</url>
    <content type="text"><![CDATA[$$口技$$ $$YRC$$ ————每日，不论何时，均有一人于东正路上吆喝，喝曰:“dē dé dē dē，dē dé dě dè。”，又曰“dē dē dē，dē dé dè。”故作一文以记之。 莞中有善口技者。行东正之大路，于莞中两区之中，无八尺横幅，口技人行东正路中，一人、一嘴而已。学生端坐。少顷，但闻路中喝一下，满坐寂然，无敢哗者。 遥观黑板中题目，便有学生困倦，老师继语。既其吆喝，大震。生亦醒。交头接耳声，相视而笑声，师斥学生声，一时齐发。窗边学生无不伸颈，侧目，微笑，默叹，以为妙绝。未几，其声又起，学生强忍莫笑。前闻有人作作索索，书本皆闭。声起，稍稍正坐。 忽一生大呼：“来也”，夫起大笑，余生亦起大笑。学生俱笑。俄而百千人大笑，百千人相论，百千回神。（东正路）中间铿镪顿挫，又夹百千笑声，相而谈论声。凡所应有，无所不有。虽人有百手，手有百指，不能指其一言；人有百口，口有百舌，不能名其一处也。于是学生无不挺立，几欲先走。 忽然喝声一下，群响毕绝。撤笔闻之，一人、一嘴而已。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSP 2019 提高组参赛总结]]></title>
    <url>%2F2019%2F11%2F21%2FCSP%202019%20%E6%8F%90%E9%AB%98%E7%BB%84%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[注：出门左转游记 今年是我第一次打提高组，也是我第二次参加竞赛的复赛。 就平日复习而言吧，可能是模板题打太多了，有些题不懂得变通之类的。 有一点，是需要反思的，就是DP非常不熟练，没有加强（想着可以暴力之类的，虽然民间数据拿了40分（D2T1T2）…..），接下来一段时间要加强DP的练习。 比赛第一天，第一题格雷码我看到时第一反应就是要用数论之类的来找规律，要先打个模拟来观察小数据，看到了数据范围$k&lt;2^{64}$也知道要开unsigned long long，但是不知道为什么在打模拟时就耗上了1个小时的时间也没打出来，每次想到一个模拟的思路，打到一半就断了，又要推翻重来。 接着又想直接手动模拟数据找规律，但也只找出了一点零散的规律，普遍的没有找到，在比赛过去1.5h时我才放弃T1去打下一题，耗时长了些。 第二题括号树，我就直接用bfs搜出所有的括号序列，再依次统计合法括号数，感觉上没什么问题，样例也过了，遇到大数据就超时，估计顶多16分。 第三题树上的数，我就直接跑深搜，但是调了半天样例数据也就过了第一、三组，另外两组都不对，时间还剩半小时，我就回去打第一题了。 重新看回第一题，不久就发现可以转二进制来做，结合一下位运算之类的，按我的想法打好后，试了样例过了，但是在自己出数据时就不对，由于还剩10分钟，我就直接放弃第一题回头检查有没有代码和文件夹问题了。 第一天感觉很不好，下午就放松了一下，看了会电视。 第二天总体感觉比第一天好很多，第一题感觉直接搜索可以有不少部分分，于是就打了个dfs+剪枝，除了选手文件的后两个数据都过了，期望得分32。 第二题划分，看完题目就反应过来是区间DP，但是DP我不熟练，就先将就着打了一下，转移方程没什么问题，就是不知道怎么处理DP后的数据。没办法，就打了个dfs来补救一下，样例过了，选手文件夹的大数据超时。 第三题树的重心，题目看完就直接放弃了，因为真的不会，没有思路，时间也不多了，我就直接拿样例中的数据找一种玄学处理方法让程序输出样例对应的正确的答案（拿入度和n处理），搞定后就回去检查了。 第二天在时间方面还是很充足的，感觉上分数应该比第一天多不少。 就这样了，第一天有不少遗憾，第二天算是尽力而为来补救了，接下来要回归文化课段二的复习了，希望能考好，不要像这次比赛一样留下遗憾。 2019-11-20 C_Cong]]></content>
      <tags>
        <tag>CSP</tag>
        <tag>OI</tag>
        <tag>比赛</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP 2019 提高组游记]]></title>
    <url>%2F2019%2F11%2F20%2FCSP%202019%20%E6%8F%90%E9%AB%98%E7%BB%84%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[注：出门左转参赛总结 声明：蒟蒻第一次打提高组，后面赛场上自然就不会打正解，请大佬勿喷。 Day 0（2019-11-15 Fri.）下午3:10，翘课出发，东莞-广州 下午4:30 到达广州萝岗万达，入住公寓酒店（27/F） 不用在意上图的人 下午6:10 晚餐 晚上8:00 上洛谷打模板 晚上9:30 集中开会，布置战术 时间安排 注意事项 如何防止爆零 晚上10:00 洗漱 晚上11:00 就寝 Day 1 (2019-11-16 Sat.)6:30 起床 8:00 到达广州二中 8:30 DAY1 Start！ Day 1 T1：格雷码？咋一看非常友好，于是着手开始模拟，当我翻到数据范围时我震惊了: What! k&lt;$2^{64}$? 不管了，先打个模拟先。 天知道我的脑子在干什么，1h都没把模拟打出来，于是开始转战数学方法。 After 30 min…. Go die，不管了，下一题。 ~ ~ 请先看完T2 T3 再回来看下面的~ ~ 比赛最后30min 猛然想起这格雷码是01串，会不会可以位运算在转二进制输出？ 手算了一下，可以！ 马上把代码敲好。 但是我再出另外一组数据测时，啊啊啊它错了…. 没时间了，算了，去检查源代码文件有没有问题了。 Day 1 T2：第一眼就看到了树状图，感觉可以爆搜一下，然后就用BFS遍历了一遍搜出所有括号序列，再每种情况统计一遍合法括号组数。 OK 样例过了 打开选手文件，把其他数据丢进来试一试，结果： T了最后一个…. 不管了，先拿部分分。 Day 1 T3：咋一看我居然看懂了，但没有想到具体要运用哪种算法，不管了，上搜索拿点分先。 距离比赛结束还有30min …..样例才过了第一组和第三组数据….. 走了走了，回第一题骗分。 12:00 比赛结束 感觉DAY1打的不行啊….明天要努力把分数挣回来…. 下午： 休息 上luogu 看番 21:40 集中开会，布置战术 老师：T1应该没人不会吧？ 我：默不作声 时间安排 ….. Day 2 （2019-11-17 Sun.）前面省略….. 8:30 DAY2 Start！ Day 2 T1:哦，做菜？ 每道菜做法不相同，主要食材不能超过所用食材一半，问方案数？ 哦！DP？ 但是多维DP很难搞欸….. DFS+剪枝！ After 1h….. 完成T1的DFS，样例OK，选手文件夹数据第4、第5，TLE。 可以了，去做T2. Day 2 T2:划分？这不是区间DP吗？ 于是把区间DP敲了出来。 看了看数据，果断放弃样例3的那种测试点（包括当type=1时的数据）。 先把DP打好，OK，走人！ Day 3 T3：emmm….树的重心…. 什么鬼…反正没多少时间了，那就： 骗分，玄学处理输入。 （具体怎么玄学的我忘了，好像是拿入度和n处理了一下） 拿样例试一试，OK，过了，期望得分5。 12:00 比赛结束 13:50 上车回校 14:55 到达学校 19:00 正常晚修 后记：听说Day 1 T1只用k^=k&gt;&gt;1再转二进制就能过？（看来我的方向没错..） By C_Cong]]></content>
      <tags>
        <tag>CSP</tag>
        <tag>OI</tag>
        <tag>比赛</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P1821 【[USACO07FEB]银牛派对Silver Cow Party】]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P1821%20%E3%80%90%5BUSACO07FEB%5D%E9%93%B6%E7%89%9B%E6%B4%BE%E5%AF%B9Silver%20Cow%20Party%E3%80%91%2F</url>
    <content type="text"><![CDATA[[USACO07FEB]银牛派对Silver Cow Party题意：有$n$头牛，$m$条路，所有牛要前往$X$牛的家开趴（当然$X$牛不用动），求其他牛去开趴来回的最短距离，输出最长的那条。 简化版题意：有$n$个节点，$m$条边，给出终点$X$，求其他节点到终点的来回最短距离，输出最长的距离。 注意：该题所给的边为有向边，别瞎*2输出使用的算法：SPFA思路：题目要找其他点到终点$X$的最短路径和终点$X$到其他点的最短路径。为便于代码实现，要进行反向建图，用SPFA跑正向的图求终点$X$到其他点的最短路径，再用跑反向图求其他点到终点$X$的最短路径。 反向图即将边的起点和终点反过来，边权不变。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;struct edge&#123; int u,v; &#125;;vector&lt;edge&gt; G[3][1001];//动态数组存边queue&lt;int&gt; Q;//队列（STL大法好）int n,m,f[3][1001],l,ans;bool vis[1001];void spfa(int k)//k=1时正向图，k=2时反向图&#123; memset(vis,0,sizeof(vis));//初始化false vis[l]=true; f[k][l]=0; Q.push(l); while(!Q.empty()) &#123; int news=Q.front(); Q.pop(); vis[news]=false; for(int i=0;i&lt;G[k][news].size();i++) &#123; int v=G[k][news][i].v,u=G[k][news][i].u; if(f[k][v]&gt;f[k][news]+u) &#123; f[k][v]=f[k][news]+u; if(!vis[v]) &#123; vis[v]=true; Q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;l); memset(f,0x3f3f3f,sizeof(f)); for(int a=1;a&lt;=m;a++) &#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); edge cmp; cmp.v=y; cmp.u=z; G[1][x].push_back(cmp);//正向建图 cmp.v=x; G[2][y].push_back(cmp);//反向建图 &#125; spfa(1);//跑正向图 spfa(2);//跑反向图 for(int a=1;a&lt;=n;a++) &#123; if(a==l) &#123; continue; &#125; ans=max(f[1][a]+f[2][a],ans);//找最长的 &#125; printf("%d\n",ans); return 0;&#125; 题目详见:https://www.luogu.org/problemnew/show/P1821]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P2872 【[USACO07DEC]道路建设Building Roads】]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P2872%20%E3%80%90%5BUSACO07DEC%5D%E9%81%93%E8%B7%AF%E5%BB%BA%E8%AE%BEBuilding%20Roads%E3%80%91%2F</url>
    <content type="text"><![CDATA[道路建设题意：给你$n$个农场的坐标，给出$m$条已经存在的路（连接农场$i$与农场$j$），求最少要修建多长的路才能把所有农场连接起来。 上面的太啰嗦了，再简化一下：给你$n$个节点，给出$m$条权值为0的边，每个节点彼此有一条边连接，边权值为两点的欧几里得距离，求该图的最小生成树大小。 欧几里得距离公式：$dis=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ 这道题我是用$Prim$做的，感觉$Prim$更好些，1000个点100条边算稀疏图吧一定要注意在计算欧几里得距离时要在$sqrt()$里加double，不然就会卡精度WA2个点 （别问我怎么知道的） 代码解析：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#define INF 20000000 //题中给出的没有那么大，但是开大点不会错using namespace std;struct edge&#123; double w;//边权 int v;//终点&#125;;vector&lt;edge&gt; G[1010];//动态数组存边int n,m,zb[1010][3],head;bool pd[1010][1010],vis[1010];double ans=0,f[1010];double dis(int xa,int ya,int xb,int yb)//求欧几里得距离&#123; return sqrt((double)(xa-xb)*(xa-xb)+(double)(ya-yb)*(ya-yb));//注意此处的两个double，被卡WA了两次&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int a=1;a&lt;=n;a++) &#123; scanf("%d%d",&amp;zb[a][1],&amp;zb[a][2]);//读入坐标 &#125; for(int a=1;a&lt;=m;a++)//标记0权边 &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); pd[x][y]=true; pd[y][x]=true; &#125; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(a==b) &#123; continue; &#125; else &#123; edge cmp; cmp.v=b; if(pd[a][b]==true)//如果被标记边权为0 &#123; cmp.w=0; &#125; else &#123; cmp.w=dis(zb[a][1],zb[a][2],zb[b][1],zb[b][2]); &#125; G[a].push_back(cmp);//存边 &#125; &#125; &#125; for(int a=1;a&lt;=n;a++)//初始化，赋极值 &#123; f[a]=INF; &#125; //下方为Prim部分 for(int a=0;a&lt;G[1].size();a++)//预处理 &#123; int v=G[1][a].v; double w=G[1][a].w; f[v]=min(f[v],w); &#125; vis[1]=true;//标记该节点已在最小生成树中 for(int i=1;i&lt;=n-1;i++)//n个节点，当然n-1条边 &#123; int V; double W=INF;//赋极值 for(int j=1;j&lt;=n;j++) &#123; if(vis[j]) &#123; continue; &#125; if(f[j]&lt;W) &#123; W=f[j]; V=j; &#125; &#125; ans=ans+W;//统计最小生成树大小 vis[V]=true;//标记该节点已在最小生成树中 for(int a=0;a&lt;G[V].size();a++) &#123; int v=G[V][a].v; double w=G[V][a].w; f[v]=min(f[v],w); &#125; &#125; printf("%.2lf\n",ans);//输出 return 0;//好习惯&#125; 题目详见:https://www.luogu.org/problemnew/show/P2872]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P1991 【无线通讯网】]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P1991-%E3%80%90%E6%97%A0%E7%BA%BF%E9%80%9A%E8%AE%AF%E7%BD%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[本题为最小生成树裸题，直接套模版按题意修改就行了本题与UVA10369相同，但要注意UVA10369有多组数据，而P1991只有一组题意： 给出n个节点的坐标，S个卫星，每个节点相互之间连通且边权为两点间距离，求这个图的最小生成树，输出最小生成树中第S-1长的边的边权，保留两位小数。 注意：S个卫星相当于S-1条边权值为0的边。 这题我是用$Prim$做的，由于看到大家发的都是Kruskal的题解，所以我就补充一篇$Prim$的。 记得存边权的变量要用double AC代码（只能借鉴，不能抄哦）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define INF 100000000const int maxn1=10002;const int maxn2=600;using namespace std;int star,n,x[maxn2],y[maxn2],h=0;bool vis[maxn2];//已经处理过的点的标记double road[maxn2],f[maxn2];//road为最小生成树中各边的边权struct edge&#123; int v;//下一个点 double w;//边权&#125;;vector&lt;edge&gt; G[maxn2];double TPD(int xa,int ya,int xb,int yb)//求两点距离（在本题即两点间的边的边权）&#123; return sqrt((double)((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)));&#125;int main()&#123; h=0;//初始化 memset(G,0,sizeof(G));//初始化 memset(vis,false,sizeof(vis));//初始化 scanf("%d%d",&amp;star,&amp;n); for(int b=1;b&lt;=n;b++) &#123; scanf("%d%d",&amp;x[b],&amp;y[b]); &#125; for(int b=1;b&lt;=n;b++) &#123; for(int c=1;c&lt;=n;c++) &#123; if(b==c) &#123; continue; &#125; else//邻接表建图 &#123; edge cmp; cmp.v=c; cmp.w=TPD(x[b],y[b],x[c],y[c]); G[b].push_back(cmp); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; f[i]=INF;//初始化f[] &#125; /* 下方开始Prim */ for(int i=0;i&lt;G[1].size();i++)//找节点1连接到另一节点的最小边 &#123; int v=G[1][i].v; double w=G[1][i].w; f[v]=min(f[v],w); &#125; vis[1]=true; for(int i=1;i&lt;=n-1;i++) &#123; double W=INF; int V; for(int j=1;j&lt;=n;j++) &#123; if(vis[j]) &#123; continue; &#125; if(f[j]&lt;W)//更新 &#123; W=f[j]; V=j; &#125; &#125; vis[V]=true;//标记已经处理过 h++; road[h]=W;//存最小生成树的边 for(int j=0;j&lt;G[V].size();j++)//找节点V连接到另一节点的最小边 &#123; int v=G[V][j].v; double w=G[V][j].w; f[v]=min(f[v],w); &#125; &#125; sort(road,road+h+1);//最小生成树边权排序 printf("%.2lf\n",road[h-star+1]);//输出第S-1长的边 return 0;&#125; 本题似乎可以在建图时把卫星作为节点处理，用于替换普通节点，不过要设置两卫星间边权为0。 题目详见：https://www.luogu.org/problem/show?pid=P1991]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 UVA10369 【Arctic Network】]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-UVA10369-%E3%80%90Arctic%20Network%E3%80%91%2F</url>
    <content type="text"><![CDATA[本题为最小生成树裸题，直接套模版按题意修改就行了本题与P1991相同，但要注意本题有多组数据，而P1991只有一组题意： 给出n个节点的坐标，S个卫星，每个节点相互之间连通且边权为两点间距离，求这个图的最小生成树，输出最小生成树中第S-1长的边的边权，保留两位小数。 注意：S个卫星相当于S-1条边权值为0的边。 这题我是用$Prim$做的，由于看到大家发的都是Kruskal的题解，所以我就补充一篇$Prim$的。 记得存边权的变量要用double AC代码（只能借鉴，不能抄哦）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define INF 100000000const int maxn1=10002;const int maxn2=600;using namespace std;int star,n,x[maxn2],y[maxn2],h=0;bool vis[maxn2];//已经处理过的点的标记double road[maxn2],f[maxn2];//road为最小生成树中各边的边权struct edge&#123; int v;//下一个点 double w;//边权&#125;;vector&lt;edge&gt; G[maxn2];double TPD(int xa,int ya,int xb,int yb)//求两点距离（在本题即两点间的边的边权）&#123; return sqrt((double)((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)));&#125;int main()&#123; int T; cin&gt;&gt;T; for(int a=1;a&lt;=T;a++) &#123; h=0;//初始化 memset(G,0,sizeof(G));//初始化 memset(vis,false,sizeof(vis));//初始化 scanf("%d%d",&amp;star,&amp;n); for(int b=1;b&lt;=n;b++) &#123; scanf("%d%d",&amp;x[b],&amp;y[b]); &#125; for(int b=1;b&lt;=n;b++) &#123; for(int c=1;c&lt;=n;c++) &#123; if(b==c) &#123; continue; &#125; else//邻接表建图 &#123; edge cmp; cmp.v=c; cmp.w=TPD(x[b],y[b],x[c],y[c]); G[b].push_back(cmp); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; f[i]=INF;//初始化f[] &#125; /* 下方开始Prim */ for(int i=0;i&lt;G[1].size();i++)//找节点1连接到另一节点的最小边 &#123; int v=G[1][i].v; double w=G[1][i].w; f[v]=min(f[v],w); &#125; vis[1]=true; for(int i=1;i&lt;=n-1;i++) &#123; double W=INF; int V; for(int j=1;j&lt;=n;j++) &#123; if(vis[j]) &#123; continue; &#125; if(f[j]&lt;W)//更新 &#123; W=f[j]; V=j; &#125; &#125; vis[V]=true;//标记已经处理过 h++; road[h]=W;//存最小生成树的边 for(int j=0;j&lt;G[V].size();j++)//找节点V连接到另一节点的最小边 &#123; int v=G[V][j].v; double w=G[V][j].w; f[v]=min(f[v],w); &#125; &#125; sort(road,road+h+1);//最小生成树边权排序 printf("%.2lf\n",road[h-star+1]);//输出第S-1长的边 &#125; &#125; 本题似乎可以在建图时把卫星作为节点处理，用于替换普通节点，不过要设置两卫星间边权为0。 题目详见：https://www.luogu.org/problem/show?pid=UVA10369]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P3952 【时间复杂度】]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P3952%20%E3%80%90%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[思路： 这是一道模拟题，看了一下数据量，纯模拟可以过，按题意来看： ERR的情况：F与E不匹配和变量名冲突的 No的情况：只有时间复杂度计算错误的 Yes的情况：除以上两种情况外的 其实还有隐藏的条件： 1.F x 1 1 为O(1) 2.F x 1 n 为O(n) 3.F x 32 n 为O(n) 4.F x n 1 为O(1) 且此语句不执行，因为n远大于100 5.并列的For语句复杂度取最高次项值 6.F x n n 为O(1) 5.F x 8 2 为O(1) 且此语句不执行，因为8大于2 6.不执行的语句若下面嵌套了新的For语句也要扫描下去，以防出现ERR的情况 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;char o[1000]=&#123;0&#125;;//存当前读入的复杂度int n,nowl,data[500],ans=0;//data存用了的变量及其值bool erk=false,erp=false;//erk判断是否少了E，erp判断变量重复void read(int r)&#123; int nd=0,rd=0,pdlt=0;//nd 目前n的次数，rd目前循环数 bool pdl=false,pdk[1000];//pdl后面嵌套的for语句是否无效，pdk记录第几次循环n的次数+1 memset(pdk,false,sizeof(pdk)); char bl[1000]=&#123;0&#125;;//存变量名 for(int b=1;b&lt;=r;b++) &#123; char g; string x,y; cin&gt;&gt;g; if(g=='F') &#123; int j=0,k=0,m=0,n=0; rd++; cin&gt;&gt;bl[rd]; if(data[(int)bl[rd]]!=0) &#123; erp=true; &#125; cin&gt;&gt;x&gt;&gt;y; if(pdl==true) &#123; continue; &#125; if(x[0]&gt;='0'&amp;&amp;x[0]&lt;='9') &#123; while(x[0+j]&gt;='0'&amp;&amp;x[0+j]&lt;='9') &#123; k=k*10+x[0+j]-48; j++; &#125; data[(int)bl[rd]]=k; &#125; else &#123; if(x[0]==n) &#123; data[(int)bl[rd]]=100; &#125; else &#123; data[(int)bl[rd]]=data[(int)x[0]]; &#125; &#125; if(y[0]&gt;='0'&amp;&amp;y[0]&lt;='9') &#123; while(y[0+m]&gt;='0'&amp;&amp;y[0+m]&lt;='9') &#123; n=n*10+y[0+m]-48; m++; &#125; if(data[(int)bl[rd]]&gt;n) &#123; if(pdl==false) &#123; pdlt=rd; &#125; pdl=true; &#125; &#125; else &#123; if(data[(int)bl[rd]]&gt;data[(int)y[0]]) &#123; if(pdl==false) &#123; pdlt=rd; &#125; pdl=true; &#125; &#125; if(y[0]=='n'&amp;&amp;x[0]!='n') &#123; nd++; ans=max(nd,ans); pdk[rd]=true; &#125; &#125; if(g=='E') &#123; if(rd&lt;0) &#123; erp=true; &#125; else &#123; data[(int)bl[rd]]=0; if(pdlt==rd) &#123; pdl=false; pdlt=0; &#125; if(pdk[rd]==true) &#123; nd--; pdk[rd]=false; &#125; rd--; &#125; &#125; &#125; if(rd!=0) &#123; erk=true; &#125; else &#123; erk=false; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int a=1;a&lt;=n;a++) &#123; erp=false; bool er=false; memset(data,0,sizeof(data)); ans=0; erk=false; data[(int)'n']=100; bool pd=false;//判断读入复杂度是否为O(n^m)类型 int fzd=0,ld=0;///fzd读入的复杂度的数字部分 scanf("%d",&amp;nowl); if(nowl%2!=0) &#123; er=true; &#125; scanf("%c",&amp;o[0]); while(o[ld]!='\n') &#123; ld++; scanf("%c",&amp;o[ld]); &#125; if(o[3]=='n') &#123; int t=0; pd=true; while(o[5+t]&gt;='0'&amp;&amp;o[5+t]&lt;='9') &#123; fzd=fzd*10+o[5+t]-48; t++; &#125; &#125; else &#123; fzd=1; &#125; read(nowl); if(er==true||erk==true||erp==true) &#123; cout&lt;&lt;"ERR"&lt;&lt;endl; continue; &#125; if(ans==0) &#123; if(fzd==1) &#123; if(pd==true) &#123; cout&lt;&lt;"No"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; &#125; else &#123; cout&lt;&lt;"No"&lt;&lt;endl; &#125; continue; &#125; if(ans&gt;0) &#123; if(fzd==ans) &#123; cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;"No"&lt;&lt;endl; &#125; continue; &#125; &#125;&#125; 题目详见:https://www.luogu.org/problemnew/show/P3952]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P5019 【铺设道路】]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P5019%20%E3%80%90%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[思路一： 一看题就知道是模拟题，直接模拟每层填土的过程。 如图所示，一共需填9次土，可以直接用for语句循环判断需填土区块的数量。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;int n,maxn=0,ans=0;int h[100000]=&#123;0&#125;;int max(int x,int y)&#123; if(x&gt;y) &#123; return x; &#125; else &#123; return y; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int a=1;a&lt;=n;a++) &#123; scanf("%d",&amp;h[a]); maxn=max(h[a],maxn); &#125; for(int a=1;a&lt;=maxn;a++) &#123; for(int b=1;b&lt;=n+1;b++) &#123; if(h[b]&lt;a&amp;&amp;h[b-1]&gt;=a) &#123; ans++; &#125; &#125; &#125; printf("%d",ans); return 0;&#125; 可惜这种方法只能拿80分的点，其他TLE。 思路2： 画图后发现，相邻的两部分所需填土的步数等于较高一部分的深度值（图中即3步） 若部分1深度&gt;部分2深度，就有步数=部分1深度 若部分2深度&gt;部分1深度，就有步数=部分2深度 所以不难推出（部分0深度=0）： 当当前部分深度&lt;前一部分深度，总步数不变 当当前部分深度&gt;前一部分深度，总步数=总步数+当前部分深度-前一部分深度 代码实现： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,ans=0,l=0;int main()&#123; scanf("%d",&amp;n); for(int a=1;a&lt;=n;a++) &#123; int p; scanf("%d",&amp;p); if(p&gt;l) &#123; ans=ans+p-l; &#125; l=p; &#125; printf("%d\n",ans);&#125; 经过测试，此思路可以轻松拿下所有点，仅耗时33ms 题目详见:https://www.luogu.org/problemnew/show/P5019]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何修改Windows7启动与关机背景]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9Windows7%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%85%B3%E6%9C%BA%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[第一步：按win+R打开运行，输入regedit打开注册表 第二步：打开注册表目录下: HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Authentication/LogonUI/Background 如图： 第三步：新建一个DWORD(32-位)值，命名为OEMBackground,并注意大小写 （若已有就直接下一步） 第四步：右键单击新建的值，选择修改，修改为下图配置，并按确定 第五步：打开目录C:\windows\system32\oobe\info\backgrounds（部分电脑无info和backgrounds文件夹，要自己新建）,将你的壁纸重命名为backgroundDefault.jpg（注意一定要是jpg格式，大小写也不能错）后放入该目录下 按win+L去到登录界面即可查看效果 图片大小不能超过250KB，图片长宽比例一般为16:9（按显示屏比例） 效果图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019中考备后记]]></title>
    <url>%2F2019%2F07%2F10%2F2019%E4%B8%AD%E8%80%83%E5%A4%87%E5%90%8E%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[总算考完中考了，考后没什么感觉，面无表情，保持了考试时的高度冷静将近一周时间。 现在成绩也出了，志愿分数线也出了，特地回博客来还愿。 突然想起之前备考记的最后两行： 现在出了的成绩： 语文：102（历史最低水平） 数学：112（还行，跟估分一模一样） 英语：118（满意，就作文扣2分） 物理：97（较满意，本来想满分） 化学：96（我想考满分的 /滑稽) 体育：100（折后60）（体育没什么好说，都是满分的） 历史：94（折后28.2）（出乎意料的高，本来想90就够了，结果中考成了三年来考的第二高的分数，最高一次96） 政治：90（折后27）（woc….我辨析题方向全错，跟答案不沾边，应该扣十分，选择虽全对，但大题加起来怎么可能在有重大失误下才扣十分，不现实，原估分80） 生物：100（折后30）（没什么好说的） 地理：98（折后29.4）（没什么好说的） 总分：736（中考系统自动四舍五入）woc 真730++ I can fly！ 但是看了别人的成绩，我自己也慌得一批（！我们班15人700+） 于是担心起分数线 果然，730++是对的，今年DGZX分数线731，我超过分数线5分 Nice！努力没白费！2019-07-10 YRC]]></content>
      <tags>
        <tag>考试</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019中考备考记]]></title>
    <url>%2F2019%2F05%2F18%2F2019%E4%B8%AD%E8%80%83%E5%A4%87%E8%80%83%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[特长生考试已结束 3年OIer生涯无悔， 140分看着就知道要咕咕了（就是没考上） 这手气我也无语了： 最后33天，初中的最后33天，肝文化课，加油！ 目标：730 计算和看题不准失分 下周二模Rp++ end. return 730;]]></content>
      <tags>
        <tag>考试</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P1443 【马的遍历】]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P1443%20%E3%80%90%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[主要思想 bfs运用队列queue减少代码量（坐标数组）简单点来说就是先从马的位置开始搜索，搜索马可以到达的点： 蓝色点即为马可以到达的点（马走日），红色为马所在位置： 上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int node[9][2]=&#123;&#123;0,0&#125;,&#123;-2,1&#125;,&#123;1,-2&#125;,&#123;2,-1&#125;,&#123;-1,2&#125;,&#123;2,1&#125;,&#123;-2,-1&#125;,&#123;1,2&#125;,&#123;-1,-2&#125;&#125;;//坐标数组，节省代码量int n,m,xs,ys,map[401][401];struct zb//结构体&#123; int x,y,bu;&#125;;queue&lt;zb&gt; Q;//队列int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;xs&gt;&gt;ys;//输入 memset(map,10000,sizeof(map));//初始化，便于后面的搜索比较和输出 map[xs][ys]=0;//一定要是0（马所在点步数为0） Q.push((zb)&#123;xs,ys,0&#125;);//进队 while(!Q.empty()) &#123; zb news=Q.front(); Q.pop(); for(int a=1;a&lt;=8;a++) &#123; if(news.y+node[a][1]&gt;0&amp;&amp;news.y+node[a][1]&lt;=m&amp;&amp;news.x+node[a][0]&gt;0&amp;&amp;news.x+node[a][0]&lt;=n&amp;&amp;map[news.x+node[a][0]][news.y+node[a][1]]&gt;news.bu+1)//又长又臭的if语句，比较步数，判断是否越界 &#123; map[news.x+node[a][0]][news.y+node[a][1]]=news.bu+1;//更新 Q.push((zb)&#123;news.x+node[a][0],news.y+node[a][1],news.bu+1&#125;); &#125; &#125; &#125; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=m;b++) &#123; if(map[a][b]&gt;=10000) &#123; printf("%-5d",-1); &#125; else &#123; printf("%-5d",map[a][b]); &#125; &#125; cout&lt;&lt;endl; &#125;&#125; 就这么简单，预祝明日特长生考试通过！题目详见:https://www.luogu.org/problemnew/show/P1443]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Minecraft生存系列（2）]]></title>
    <url>%2F2019%2F02%2F13%2F%E6%88%91%E7%9A%84Minecraft%E7%94%9F%E5%AD%98%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[存档快两个月了，怎么说也会发生翻天覆地的变化了。 世界时间：Day 66 这一个月主要也就升级了一下内部装饰，然后就是采集资源。 不要问我问什么还没打龙，因为没遇过小黑（谁叫我老是在地底工作） 添加部分：瞭望塔： 活塞门： 家（实体建筑）： 铁匠铺： 附魔室： 酿药室： 刷石机： 小型生态建筑： 地下社区： 升级部分：农场： 新进度：废弃矿坑： 洞穴蜘蛛刷怪笼： 期待下一篇报导！]]></content>
      <tags>
        <tag>我的世界</tag>
        <tag>Minecraft</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pixiv 手机版登录教程]]></title>
    <url>%2F2019%2F02%2F08%2Fpixiv-%E6%89%8B%E6%9C%BA%E7%89%88%E7%99%BB%E5%BD%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[上个月发了一篇电脑版的，现在就来介绍一下手机版的吧。 由于手机端似乎没有host，所以只能借助一下外国的神奇软件了。 软件谷歌空间 安装完成后即可进入下一步 步骤下载pixiv 打开谷歌空间，搜索pixiv，下载安装 准备环境去到谷歌空间启动栏，点击pixiv图标，会提示准备谷歌运行环境。 若没有出现下图所示进度条，则需重启谷歌空间，重复上述步骤： 网络加速 在启动页点击加速，选择日本或台湾线路即可 完成 点击pixiv，若如上图所示则表示成功（当然第二张是登陆后的）]]></content>
      <tags>
        <tag>教程</tag>
        <tag>pixiv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建说明书（指北书）]]></title>
    <url>%2F2019%2F02%2F01%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%88%E6%8C%87%E5%8C%97%E4%B9%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[提起博客，这似乎是一个需要氪金的工程，实不然。 我开始的理解：博客=域名（at least 10￥）+代码（HTML、CSS、JavaScript…）+服务器（at least 3000￥） 但后来，当我看到Hexo这款神奇的开源的静态博客生成器，就彻底改变了我的想法。 网上有很多教程，但总找不到全面和有效的（本来Hexo的坑就多），所以今天就和各位分享一下。 优点 应用markdown，易于编辑，博客前端自动生成无需搭建 能够像手机一样自由添加应用（即插件） 无需基础，只要你对代码敏感就好 缺点： 博客访问用的文件生成的速度和上传博客的速度跟电脑配置有关，一般较慢 博客源文件（配置好）占用你的硬盘内存较大，一般接近1G或以上 材料/工具: 一个github账号 git node.js 安装完成后即可进入下一步。 基础配置:本地：本步骤时间较长，请耐心等待。 在本地创建一个新的文件夹（必须为新的/空的），名字自行定义。 打开文件夹后鼠标右键打开Git Bash。 输入npm install -g hexo下载Hexo 输入hexo init安装Hexo（此时文件夹下会陆续出现文件/文件夹） 输入npm install安装必要配置包 输入hexo s启动Hexo，打开浏览器输入地址localhost:4000查看 云端：在github上新建存储库你的github用户名.github.io 进入存储库后，打开这里： 找到这行并修改成如下： 在Git Bash中输入ssh-keygen生成SSH密钥，并按三次回车，随后用记事本打开C:\Users\Administrator\.ssh\id_rsa.pub（本目录因电脑而异，大部分相同），把内容复制下来，打开https://github.com/settings/keys,新建一个SSH Key，粘贴key项目内（title随便填），最后按下add SSh key。 回到Git Bash，输入ssh -T git@github.com,若显示Hi!xxxx的字眼，则代表成功。 接下来输入npm install hexo-deployer-git --save安装上传工具deployer 打开文件夹根目录下的_config.yml，找到如下部分并按要求修改： 注意：该配置项:后要有两个空格（当时就把我坑到了） 1234deploy: type: git repository: git@github.com:你的github用户名/你的github用户名.github.io.git branch: master 输入hexo g生成静态博客文件 输入hexo d上传文件至github 若是首次上传，会失败，会有以下提示： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail@example.com&quot; 将这两行指令分别复制并将yorname``youremail@example.com分别替换成你的github用户名与注册邮箱，重新粘贴至Git Bash即可。 博客配置：终于到最复杂的环节了，但其实认真读一遍说明你就会感到豁然开朗。 我这里就只介绍NexT主题（V6.7.0）中的Gemini风格的配置，同主题不同风格注意_config.yml中的设置限制（基本没有限制），其他主题参阅官网（其实大都相似） 以下所有步骤均建议配置完成后输入hexo s启动本地浏览，进入localhost:4000验证。 主题安装：下载NexT主题（V6.7.0） 把压缩包直接解压到博客根目录下的theme文件夹内： 打开博客根目录下的_config.yml，找到这行并修改成如下： 1theme: hexo-theme-next-6.7.0 首页标题/名字/语言设置打开博客根目录下的_config.yml. 其它语言参照/theme/languages/下的语言配置文件（可魔改） 例子： 123456789101112# 标题title: YRC的博客#小标题subtitle: Nothing is impossible！description:keywords:# 名字author: YRC# 语言language: zh-CN# 时区（不建议使用）timezone: 博客图标：1234favicon: # 网站图标-放在主题目录下/source/images/,按照你的图标名修改以下两行即可 small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png 目录：主目录： 按个人所需使用，每行设置前加#的为不显示。 home 主页 about 关于 tags 标签（配置在下文会提到） archives 归档 其他的项目不建议小白使用（因为真的没什么用） 若要添加新的选项，按照name: /(在博客根目录下source文件夹下的地址) || 图标,并在Git Bash输入hexo new page &quot;about&quot;新建页面，在/soure/about/index.md内即可编辑 图标的名字参照官网 1234567891011menu: # 目录 home: / || home about: /about/ || user tags: /tags/ || tags # categories: /categories/ || th archives: /archives/ || archive # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: 404.html || false # 加#号的用处不大，在此不赘述（且要安装插件） 文章内部目录栏 123456789toc: # 是否生成文章目录 enable: true # 目录是否自动添加序号 number: true # 目录中的字符长度若大于目录栏宽度，多余的字符则放下一行，否则多余字符以省略号代替 wrap: false # 默认即可 max_depth: 6 目录栏的位置：1234sidebar: # 目录栏在博客中的位置 left | right (only for Pisces | Gemini). position: left #position: right 设置主题风格123456# Schemes# NexT主题下的四种风格#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 社交网站 || 后面的仍为图标名，参照上文中目录图标设置即可。 例子： 123456social: # 社交网站 GitHub: https://github.com/dgsyrc || github E-Mail: mailto:yrcminecraft@qq.com || envelope luogu: https://www.luogu.org/space/show?uid=89910 || code bilibili: http://space.bilibili.com/179225431? || tv 若不想显示图标，则将下面这行设置为false. 12345social_icons: # 不显示图标 enable: false # 只显示图标 icons_only: false 友情链接 123456789101112131415# 标题前图标links_icon: link# 标题links_title: 友情链接(部分需翻墙)# 排版设置（不加#为设置项，加#不设置，二者不可~~得兼~~同时设置）#一行一个#links_layout: block #一行多个links_layout: inline# 链接links: cloudflare: https://dash.cloudflare.com freenom: https://my.freenom.com/clientarea.php Minecraft Wiki: https://minecraft-zh.gamepedia.com/Minecraft_Wiki Pixiv: https://www.pixiv.net 头像12345678910# 头像avatar: # 头像地址（以根目录下的source为根目录的地址，而非主题下的source） url: /images/main.png # 头像圆形 rounded: true # 0不显示头像，1显示 opacity: 1 # 头像旋转 rotated: true 返回顶部按钮： 找到如下代码： b2t: true为显示，b2t: false为不显示。 1234# 返回顶部按钮 b2t: true # 显示阅读百分比 scrollpercent: true 阅读全文按钮：enable: true为主页显示全文，enable: false为主页不显示全文。 123456auto_excerpt: enable: true # 主页每篇文章显示字数 length: 150# 在主页是否显示阅读全文按钮read_more_btn: true 文章字数/阅读时长统计 在Git Bash中输入以下指令，安装插件。 1npm install hexo-symbols-count-time --save 修改如下代码： 博客目录下_config.yml： 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 主题目录下_config.yml： 1234567# 博客字数，阅读时长统计symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 代码复制按钮1234567codeblock: border_radius: copy_button: # 是否启用 enable: true # 是否提示复制成功 show_result: true 使用$Latex$当per_page: true时，只有博文中有mathjax: true时才启用，若为false,则每篇文章都启用。 1234567math: # 是否启用 enable: true per_page: true # 推荐使用mathjax engine: mathjax #engine: katex 分享页面左边浮动按钮： 文章底部： 在Git Bash中输入git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton安装插件。 修改如下配置： 12345678910111213141516171819needmoreshare2:# 添加分享按钮 enable: true postbottom: # 每一篇文章底部显示按钮 enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: # 页面左边显示浮动按钮 enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 访问统计文章访问统计： 博客访问统计： 修改如下设置即可： 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 站内搜索 在Git Bash中输入npm install hexo-generator-searchdb --save安装插件。 在博客目录下的_config.yml添加如下设置： 12345search: path: search.xml field: post format: html limit: 10000 在theme目录下的_config.yml修改如下设置： 12345# 站内搜索local_search: enable: true top_n_per_article: 1 unescape: false 书签添加书签后，访客每次访问文章时会返回到上次阅读的那行。 在Git Bash中输入git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark安装插件。 12345678# 书签bookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: auto 标签在Git Bash中输入hexo new page &quot;tags&quot;新建Tag页面。 然后向source\tags\index.md中添加一行： 1type: &quot;tags&quot; 文章标签的设置如下： 1234tags:- 标签1- 标签2- 标签3 背景打开themes目录下\source\css\_custom\custom.styl 添加如下代码: 123456789body &#123; background-image:url(/images/background2.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover;&#125;.main-inner &#123; opacity: 0.9;&#125; background-image:url:背景链接，目录默认为主题目录下的\soure\images\ background-repeat: no-repeat:背景图不重复出现 background-size: cover:平铺 opacity::不透明度 鼠标点击显示爱心图案下载js： 将该js放在主题根目录下\source\js\src内。 打开layout/_layout.swig,在文件末尾添加一行： 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 文章的撰写新建文章在Git Bash输入hexo new &quot;文章名&quot;新建文章 如想在文中引用博客内图片，则需修改博客目录下的_config.yml的这一行（为true即可），以便以后使用hexo new命令时自动生成文件夹，需引用的图片需放在博客根目录下的\source\_post\文章名\内： 1post_asset_folder: true 除了可以使用命令添加文章外，还可以直接在_post文件夹内直接新建文章名.md与文件夹文章名，但是文章名.md内必须按照以下格式： 12345678---title: 文章名mathjax: true（此行可去）date: 2019-02-01 12:30:42（可自定义，当然设为1000-01-01 00:00:00是没有问题的）tags:- Tag1- Tag2--- 撰写打开\source\_post\文章名.md 按照markdown的语法写即可。 完成部分效果可参考我的hexo博客]]></content>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习作-遇见檀香]]></title>
    <url>%2F2019%2F01%2F26%2F%E4%B9%A0%E4%BD%9C-%E9%81%87%E8%A7%81%E6%AA%80%E9%A6%99%2F</url>
    <content type="text"><![CDATA[遇见檀香 &#160; &#160; &#160; &#160;神台的周围烟雾缭绕，檀香四溢，奶奶口中的喃喃细语，耳边萦绕。&#160; &#160; &#160; &#160;那是那年过年之时，我和父母早早地就来到了老家。红色的对联，响亮的鞭炮声，到处都洋溢着新年的气氛。看到爷爷，我便快步走向前，相互祝福了一番，讨了个红包，随后就去找奶奶。&#160; &#160; &#160; &#160;找到奶奶时，她正在整理神台，上面的祭品摆放得整整齐齐。跟着他便点燃檀香，轻轻地插在神台上，顿时四周变得烟雾缭绕起来。&#160; &#160; &#160; &#160;她拾起桌上的一沓金银纸，放在手心，双手合十，面对着檀香，口中念念有词，开始时我很不理解，认为这是迷信，但我又伫立听了一阵，那声声祷告，竟都是对子孙美好的祝愿。&#160; &#160; &#160; &#160;记得那次，我因贪玩，在神台上多插了几根檀香，又偷偷地拿来打火机，把檀香点燃，随后我又对着檀香开始拼命地吹。这这时，奶奶来了，她一把夺过我手中的打火机，然后拿起神台上正冒着烟的檀香，留下了三根插回神台，又急匆匆地把剩下的檀香分别插在其它香炉上，一阵子，就回到了神台前，低下额头，闭上眼睛，双手合十，嘴中又不知念叨了些什么，随后就回去做刚才未完成的事了。&#160; &#160; &#160; &#160;我本不信佛，但是奶奶她那虔诚的祷告声，却让我沉迷在其中，却让我看到了她对我们这个家庭默默的付出，让我终于明白了这些檀香、祭品存在的含义。&#160; &#160; &#160; &#160;檀香的烟雾渐浓，似蓬莱仙境，又似菩萨显灵。那一声声祷告，一句句祷词，实是人到暮年时的一种精神寄托，也是对子孙的美好祝愿，我们更应多陪伴他们，让他们的心里更加得踏实，更能安度晚年。&#160; &#160; &#160; &#160;那声声悼词，阵阵檀香，仍在我耳边回环萦绕，眼前缭绕，久而不散。 本文为作者原创，未经本人许可禁止转载！]]></content>
      <tags>
        <tag>学习</tag>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pixiv 电脑版登录教程]]></title>
    <url>%2F2019%2F01%2F26%2Fpixiv-%E7%94%B5%E8%84%91%E7%89%88%E7%99%BB%E5%BD%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前天我突然发现pixiv挂蓝灯进不去了，纯host也不行，于是经过我大量的资料搜索，终于发现了一条拯救之路。 不说这么多，基本上看图就懂。 下载配置包链接：https://github.com/dgsyrc/file/blob/master/Pixiv.rar?raw=true 把配置包解压到纯英文字母路径的目录下（推荐D:) 安装证书 更改host host目录在 C:\Windows\System32\drivers\etc 下 打开host，把下面的东西复制在host文件里 123456789101112131415161718192021222324252627282930127.0.0.1 www.google.com#Pixiv Start127.0.0.1 pixiv.net 127.0.0.1 www.pixiv.net 127.0.0.1 ssl.pixiv.net127.0.0.1 accounts.pixiv.net 127.0.0.1 touch.pixiv.net127.0.0.1 oauth.secure.pixiv.net127.0.0.1 dic.pixiv.net127.0.0.1 en-dic.pixiv.net 127.0.0.1 sketch.pixiv.net127.0.0.1 payment.pixiv.net127.0.0.1 factory.pixiv.net 127.0.0.1 comic.pixiv.net 127.0.0.1 novel.pixiv.net 127.0.0.1 imgaz.pixiv.net 127.0.0.1 sensei.pixiv.net127.0.0.1 fanbox.pixiv.net210.140.92.136 i.pximg.net210.140.131.145 source.pixiv.net210.129.120.50 app-api.pixiv.net 74.120.148.207 g-client-proxy.pixiv.net 210.140.131.145 i1.pixiv.net 210.140.131.145 i2.pixiv.net 210.140.131.145 i3.pixiv.net 210.140.131.145 i4.pixiv.net 210.140.131.159 d.pixiv.org 210.140.92.135 pixiv.pximg.net 210.140.92.134 s.pximg.net#Pixiv End 运行工具 打开后按下这个按钮 测试请使用firefox浏览器，谷歌chrome和国内浏览器不行 打开pixiv.net后，如图操作： 确认安全例外后即可，若登陆页出现相同情况，进行相同操作即可 完成！更详细的的教程（我就是参考了这篇才成功的）：https://2heng.xin/2017/09/19/pixiv/]]></content>
      <tags>
        <tag>教程</tag>
        <tag>pixiv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习作-风雨中的坚持也是一种爱]]></title>
    <url>%2F2019%2F01%2F22%2F%E4%B9%A0%E4%BD%9C-%E9%A3%8E%E9%9B%A8%E4%B8%AD%E7%9A%84%E5%9D%9A%E6%8C%81%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E7%88%B1%2F</url>
    <content type="text"><![CDATA[风雨中的坚持也是一种爱 &#160; &#160; &#160; &#160;爱，是初春的阳光，是寒冬时的炭火，点点温暖，入人心，也是那风雨中无畏的坚持。&#160; &#160; &#160; &#160;那天晚上，我正在班上晚自习，时间虽已是深秋，天空也早已落下黑色的帷幕，但空气仍闷热到使人快透不过气来。在快下课的时候，雨终于沙沙地下了起来。&#160; &#160; &#160; &#160;下课了，我把书盖在头上，冲向校门，去寻觅那身穿黄色雨衣的高大身影——那是我的父亲。来到他的身旁时，他正帮我擦干座椅。待擦干，我便跨上座椅，披上雨衣，他在我坐好后，也启动了电动自行车。&#160; &#160; &#160; &#160;雨渐渐地大了起来，周围的一切都开始变得朦胧，模糊了。此时的我巴不得快点到家，远离那些冰冷的雨滴，越远越好。&#160; &#160; &#160; &#160;风从我耳边呼呼地刮过，雨也斜着密密麻麻地打在我的脸上。“咔”的一声，车子突然慢了下来，是车子断电了，他立即挺起身子，猛地开始蹬着电动自行车的脚踏板，很快地，车速又回到了断电前，他似要和我一样，尽快回到家，远离这片风雨。&#160; &#160; &#160; &#160;雨倾盆而下，像是要把这辆自行车吞噬，周围来往的都是匆匆赶路回家的人，我也一样。车速渐缓，我又开始着急了起来，本想叫父亲再快一些，但我静心一听，一声声粗气从我前面传来，不禁使我心头一紧，转而纠结了一下，便对他说：“爸，反正快到了，旁边也有挡雨的，走回去就好了。”他没有搭理我，反而又加快了车速，想回家的方向疾驰而去。&#160; &#160; &#160; &#160;总算来到了家楼下，他脱下雨衣，摘下口罩，在昏暗的灯光下，父亲似乎比前些年多了几丝皱纹。我又想起以前同是下雨天的一个晚上他对我考砸后的悉心安慰。我幡然醒悟到父亲不能坚持陪我们一辈子，我也不能等到“子欲养而亲不待”之时才尽心报答他。&#160; &#160; &#160; &#160;父亲所给予我的爱不是无穷无尽的，尽管“父爱如山”，但它也会有消失的一天，我所要做的，就是在它消失前好好保护它，爱护它，不论风雨，也要坚持下去。 本文为作者原创，未经本人许可禁止转载！]]></content>
      <tags>
        <tag>学习</tag>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI-GIF图集(1)]]></title>
    <url>%2F2019%2F01%2F21%2FOI-GIF%E5%9B%BE%E9%9B%86(1)%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>OI</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十校联考-九上期末考试后记]]></title>
    <url>%2F2019%2F01%2F18%2F%E4%BA%8C%E5%8D%81%E6%A0%A1%E8%81%94%E8%80%83-%E4%B9%9D%E4%B8%8A%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%90%8E%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[考完试了，当然要补一篇后记。 考试的时候慌得一批，难度比以往的大。 数学考试最后一道9分题两问没写，化学涂错一道选择题，计算带错数。 考完估分：698.9~705 然而…… 总分退了4分，级排还进了……. 历史居然考微积分…… 最后，在收拾试卷时，发现 13cm! 我居然写了这么多试卷！ 好了，是时候开始写寒假作业了。 The end.(自此日起距中考还剩152天)]]></content>
      <tags>
        <tag>考试</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI题库-1.1编程基础之输入输出题解]]></title>
    <url>%2F2019%2F01%2F17%2FNOI%E9%A2%98%E5%BA%93-1-1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[由于此部分太水，所以不附解析，只附代码 题目详见：http://noi.openjudge.cn/ch0101/ Hello, World!123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello, World!"&lt;&lt;endl;&#125; 输出第二个整数12345678#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;b&lt;&lt;endl;&#125; 对齐输出123456789#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; long long a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;setw(8)&lt;&lt;a&lt;&lt;' '&lt;&lt;setw(8)&lt;&lt;b&lt;&lt;' '&lt;&lt;setw(8)&lt;&lt;c&lt;&lt;endl;&#125; 输出保留3位小数的浮点数123456789#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; float a; cin&gt;&gt;a; cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;a&lt;&lt;endl;&#125; 输出保留12位小数的浮点数123456789#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; double a; cin&gt;&gt;a; cout&lt;&lt;fixed&lt;&lt;setprecision(12)&lt;&lt;a&lt;&lt;endl;&#125; 空格分隔输出123456789101112#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; int b; char c; float d; double a; cin&gt;&gt;c&gt;&gt;b&gt;&gt;d&gt;&gt;a; cout&lt;&lt;c&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;d&lt;&lt;' '&lt;&lt;a&lt;&lt;endl;&#125; 输出浮点数12345678910111213#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; double a; scanf("%lf",&amp;a); printf("%lf\n",a); printf("%.5lf\n",a); printf("%e\n",a); printf("%g\n",a); &#125; 字符三角形1234567891011#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; char a; cin&gt;&gt;a; printf(" %c\n",a); printf(" %c%c%c\n",a,a,a); printf("%c%c%c%c%c\n",a,a,a,a,a);&#125; 字符菱形12345678910111213#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; char a; cin&gt;&gt;a; printf(" %c\n",a); printf(" %c%c%c\n",a,a,a); printf("%c%c%c%c%c\n",a,a,a,a,a); printf(" %c%c%c\n",a,a,a); printf(" %c\n",a);&#125; 超级玛丽游戏12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; printf(" ********\n"); printf(" ************\n"); printf(" ####....#.\n"); printf(" #..###.....##....\n"); printf(" ###.......###### ### ### ### ###\n"); printf(" ........... #...# #...# #...# #...#\n"); printf(" ##*####### #.#.# #.#.# #.#.# #.#.#\n"); printf(" ####*******###### #.#.# #.#.# #.#.# #.#.#\n"); printf(" ...#***.****.*###.... #...# #...# #...# #...#\n"); printf(" ....**********##..... ### ### ### ###\n"); printf(" ....**** *****....\n"); printf(" #### ####\n"); printf(" ###### ######\n"); printf("############################################################## ##################################\n"); printf("#...#......#.##...#......#.##...#......#.##------------------# #...#......#.##------------------#\n"); printf("###########################################------------------# ###############------------------#\n"); printf("#..#....#....##..#....#....##..#....#....##################### #..#....#....#####################\n"); printf("########################################## #----------# ############## #----------#\n"); printf("#.....#......##.....#......##.....#......# #----------# #.....#......# #----------#\n"); printf("########################################## #----------# ############## #----------#\n"); printf("#.#..#....#..##.#..#....#..##.#..#....#..# #----------# #.#..#....#..# #----------#\n"); printf("########################################## ############ ############## ############\n"); &#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>NOI题库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷管理语录（1）]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B4%9B%E8%B0%B7%E7%AE%A1%E7%90%86%E8%AF%AD%E5%BD%95%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>图片</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十校联考-九上期末考试备考记]]></title>
    <url>%2F2019%2F01%2F12%2F%E4%BA%8C%E5%8D%81%E6%A0%A1%E8%81%94%E8%80%83-%E4%B9%9D%E4%B8%8A%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Start an all-round attack on the target!开始对目标发起全面进攻！]]></content>
      <tags>
        <tag>考试</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Minecraft生存系列（1）]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%88%91%E7%9A%84Minecraft%E7%94%9F%E5%AD%98%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[存档快一个月了，想着博客刚刚更新没多久，我还是决定分享一下成果吧！（不会告诉你大部分时间是在机房FB推存档进度的） 世界时间：Day32 物品：矿物： 绿宝石*6钻石*35金锭*50萤石粉*64青金石*102铁锭*54 （我好穷啊）石英*68红石粉*561煤炭*7 （wdf）金粒*7 （猪人赠）当然数据这只是这个箱子里的，加上其他地方的也就多一点而已了 战利品： 金剑*3 （来自友好的猪人）金胸甲*2 （来自友好的猪人）金马铠*6 （地狱堡垒）铁马铠*4 （地狱堡垒）钻石马铠*1 （穿在我家白龙马上了）鞍*1 （沙漠神殿）金苹果*1 （地狱堡垒）粘液球*27 （在另一个箱子里）命名牌*2附魔书：爆炸保护Ⅲ （沙漠神殿）经验修补 （钓鱼）锋利Ⅲ （沙漠神殿）火焰保护Ⅲ 水下呼吸Ⅱ （钓鱼….）力量Ⅳ 锋利Ⅲ （钓鱼….出神装….）要致富，先钓鱼 酿药： 原料：地狱疣*107红石粉*8 （前面矿物箱还有一大把）萤石粉*43河豚*2烈焰棒*5金粒*9糖*8成品：力量药水（8:00）*3迅捷药水（8:00）*3水肺药水（8:00）*3家：基本属性：坐标：X：1424 Y：7 Z:-1430大小：不会算…挖了约64*64=4096块石头左右设施：通道： 客厅/厨房： 木有家具欸… 农场： 甘蔗小麦南瓜地狱疣牧场：牛/羊： 鸡： 马（白龙马）： 储物室： 附魔室+地狱传送门： 酿药室： 荒废的史莱姆农场： 重生点-床（地底有Bug，设不了）： 周边-岩浆湖： 进度：地狱： 地狱堡垒： 烈焰人刷怪笼： 期待下一篇生存系列报导！]]></content>
      <tags>
        <tag>我的世界</tag>
        <tag>Minecraft</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P3955 【图书管理员】]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P3955%20%E3%80%90%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E5%91%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看了下面一堆大佬的代码，感觉好麻烦，其实无需排序直接对每一次询问进行比较就好了（反正数据不大，用不上字符串）。 附代码： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int n,q,nl[1001],ql[1001],qsl[1001];/*n为图书馆里书的数量，q为读者的数量，nl是书的编码，ql是询问的编码，qsl是询问的编码的长度*/int main()&#123; cin&gt;&gt;n&gt;&gt;q;/*输入*/ for(int a=1;a&lt;=n;a++) &#123; cin&gt;&gt;nl[a];/*读入书的编码*/ &#125; for(int a=1;a&lt;=q;a++) &#123; int ans=-1,k=1; cin&gt;&gt;qsl[a];/*读入询问编码的长度*/ cin&gt;&gt;ql[a];/*读入询问的编码*/ for(int c=1;c&lt;=qsl[a];c++)/*处理比较的数位*/ &#123; k=k*10; &#125; for(int b=1;b&lt;=n;b++)/*逐书比较*/ &#123; if(nl[b]%k==ql[a])/*取书的编码的末qsl[a]位与询问编码比较*/ &#123; if(ans==-1||(ans&gt;nl[b]))/*判断是否未找到或是否比已找到的小*/ &#123; ans=nl[b];/*读入已知书编码最小值*/ &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;/*输出*/ &#125;&#125; 题目详见:https://www.luogu.org/problemnew/show/P3955]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UMR IT Team 团队守则]]></title>
    <url>%2F2018%2F08%2F30%2FUMR-IT-Team-%E5%9B%A2%E9%98%9F%E5%AE%88%E5%88%99%2F</url>
    <content type="text"><![CDATA[关于团队：本团队是一个和谐的信息技术交流团队 团队已加入 团队联盟 团队分组：主团：QWQ：管理员 dalao：用户 合作伙伴：合作的团队的管理员（仅限一人，团队主优先） ky：em….团队主学校的OIer Rank#1：团队比赛的NO.1（不具备管理权限） 分团：QWQ：管理员 出题团：贡献题目的用户 dalao：用户 Rank#1：团队比赛的NO.1（具备管理权限） 合作伙伴：合作的团队的管理员（仅限一人，团队主优先） 比赛：1.团队管理可以创建比赛，题目难度不限，但不可以违反洛谷的规章制度。 2.团队管理创建的比赛的比赛时间最多1个月。 3.除比赛创建者外，任何成员不得修改比赛，造成的后果小则进行警告，大则免去其管理权限或踢出团队。 4.奖励制度： 比赛结束后第一的直接升为管理员权限（分团），并分组到 Rank#1 组 题目：1.团队管理可以直接创建题目，题目难度不限，但不可以违反洛谷的规章制度。 2.除题目创建者外，任何成员不得不经创建者允许修改题目，造成的后果小则进行警告，大则免去其管理权限或踢出团队。 3.若有用户想为团队提供题目的，请找管理员，并由管理员审核和上传题目。 管理员：1.管理员分两类：分团和主团，团队中权限最大的是QWQ类管理员，主团中只允许有QWQ分类的管理员（目前不开通新管理的招聘）。 2.管理员不得授权其他成员管理权限，一经发现，没收其管理权限并不得在升为管理。 合作伙伴：概述：1.合作伙伴经管理员认证的可获得管理资格（分团）。 2.合作伙伴必须严守管理员规则，否则T出团队。 3.合作伙伴不得在在其他团队乱打团队广告，骚扰他人，严重者撤销其管理权限并取消合作。 审核条件：1.仅限团队主申请。 2.团队需30人以上。 3.题目储存需有5道及以上。 4.该团队成员至少有6人以上加入本团队。 5.一名团队主只可申请合作一次。 6.不接受有违规纪录的团队的申请。 2018-08-03 UMR IT Team 管理团]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Blog的更新]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%85%B3%E4%BA%8EBlog%E7%9A%84%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[打了一下午的代码，主要就是美化了页面，把头部和尾部改成了各用了一个内联框架，使用了公共头部与尾部，方便以后对头部和尾部的修改，然后顺便将原来左侧的按钮改到了头部，至于头部的About吧，到时候会链接到一篇关于博客功能与意义的文章，不会像现在一样链接到主页了，顺便还要感谢洛谷的某位童鞋，帮我解决了网页去白框的问题（加了一句 margin: 0px!important），这样博客的主体及基本完工了。 美化前后对比： 主页： 文章目录： 文章： 团队：]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用github搭建一个个人图床]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[相信很多洛谷的伙伴们都很喜欢发图，发图最重要的是图床。 但是，现在我要介绍的是一种无水印原图的图床，我们要借助github这个平台来搭。 github的好处在于它会给每个用户分配一个域名，域名的分配规则是： 你的github用户名.github.io 注意：用户名尽量用英文。 翻译： repositories 存储库 1.在github上注册一个账号后点击右上角的Your repositories: 2.进入repositories界面后点击new创建一个新的存储库，建议存储库命名为：你的github用户名.github.io（如果你已经使用了该存储库那就可以自定义，但是后面的图片链接会有一点不同） 3.创建成功后，先建立一个README文件 4.随后点击上方的Setting并往下拉，去到GitHub Pages设置项，把Source项设定为master branch（如若已设定好则不必改动） 5.最后就可以到存储库里存图了，上传会有几率失败，要多试几次 6.上传完成后即可到你的https://yourgithubname.github.io/你的图片名（加后缀名） 来查看图片了，可以将本链接作为图片链接用到Markdown上。（如果开始你的存储库名是你自定义的，就要把链接改成https://yourgithubname.github.io/存储库名/你的图片名（加后缀名）） 当然，github也是可以搭建网站的。]]></content>
      <tags>
        <tag>教程</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干物妹！小埋！第三弹 比赛题解]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%B9%B2%E7%89%A9%E5%A6%B9%EF%BC%81%E5%B0%8F%E5%9F%8B%EF%BC%81%E7%AC%AC%E4%B8%89%E5%BC%B9-%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Problem A（小埋与NOIP）：此题其实是计算加权平均数，模拟公式过程再输出最大值即可。 $\bar{x}=\dfrac{x_1w_1+x_2w_2+…+x_nw_n}{w_1+w_2+…+w_n}$ 附标程： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; string name[6]; int lv[1000]=&#123;0&#125;,s[6][1000]=&#123;0&#125;,sco[6]=&#123;0&#125;,a,alv=0,ansm=0,anss=0; /*输入*/ cin&gt;&gt;a; for(int b=1;b&lt;=a;b++) &#123; cin&gt;&gt;lv[b]; alv=alv+lv[b]; &#125; for(int b=1;b&lt;=5;b++) &#123; int p=0; cin&gt;&gt;name[b]; /*模拟过程*/ for(int c=1;c&lt;=a;c++) &#123; cin&gt;&gt;s[b][c]; p=p+s[b][c]; &#125; sco[b]=p/alv; if(anss&lt;sco[b])/*比较*/ &#123; anss=sco[b]; ansm=b;/*最大值所在位置*/ &#125; &#125; cout&lt;&lt;name[ansm]&lt;&lt;endl;/*输出*/&#125; Problem B（小埋与数羊）：裸DP题，可以通过求从第一行出发后每个点所能得出的最大值，转移方程为：q[a][b]=max(q[a][b],q[a-1][c]+_map[a][b]); 附标程（效率还是比较低，没压缩）： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int pa,ans;int n,_map[100010][5]=&#123;0&#125;,q[100010][5]=&#123;0&#125;;int main()&#123; cin&gt;&gt;n; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=4;b++) &#123; cin&gt;&gt;_map[a][b]; q[a][b]=_map[a][b]; &#125; &#125; pa=0; for(int a=2;a&lt;=n;a++) &#123; for(int b=1;b&lt;=4;b++) &#123; for(int c=1;c&lt;=4;c++) &#123; if(b==c) &#123; continue; &#125; else &#123; q[a][b]=max(q[a][b],q[a-1][c]+_map[a][b]); &#125; &#125; &#125; &#125; for(int a=1;a&lt;=4;a++) &#123; ans=max(q[n][a],ans); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Problem C（小埋与二分法）：又是字符串，不过这次复杂了很多，但脑洞就没有上次的Problem C（小埋与TSF的密信）那么大，可能很多人提交之后都会怀疑数据有问题，那你就错了，其实你们题目可能漏了一点没有看，那就是： 输入数据是密文！本题的题意其实是让你按照加密过程的逆过程来解密，可能有人会连加密过程都看不懂，那我就图解一下吧： 再简单点说其实就是先序遍历转中序遍历附标程： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;char a[201000],s[201000];int k;void dg(int l,int r)/*“逆”二分*/&#123; int mid=(l+r)&gt;&gt;1;/*位运算&gt;&gt;1其实是div2*/ a[mid]=s[k]; k++; if (l&lt;mid) &#123; dg(l,mid-1); &#125; if (r&gt;mid) &#123; dg(mid+1,r); &#125;&#125;int main()&#123; k=0; scanf("%s",s);/*输入*/ int l=strlen(s)-1; dg(0,l); /*输出*/ for (int i=0;i&lt;=l;i++) &#123; printf("%c",a[i]); &#125; printf("\n");&#125; 比赛详见:https://www.luogu.org/contestnew/show/9387]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干物妹！小埋！第二弹 比赛题解]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%B9%B2%E7%89%A9%E5%A6%B9%EF%BC%81%E5%B0%8F%E5%9F%8B%EF%BC%81%E7%AC%AC%E4%BA%8C%E5%BC%B9%20%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Problem A（小埋与Chicken rabbit with cages）：此题为典型的鸡兔同笼问题，原意用于照顾蒟蒻，故比较简单，模拟解方程组即可。 $ x+y=head $ $ 2x+4y=leg $ 附标程： 12345678910111213141516171819#include&lt;iostream&gt;namespace UMR/*防抄袭命名空间*/&#123; long long a=0,b=0,x=0,y=0; int n;&#125;;using namespace std;using namespace UMR;int main()&#123; cin&gt;&gt;n; for(int d=1;d&lt;=n;d++) &#123; cin&gt;&gt;a&gt;&gt;b; y=(b-2*a)/2; x=a-y; cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; &#125;&#125; Problem B（小埋与哥哥的企划）：采用深度优先搜索（DFS）算法，可以从两个角度出发： （1） 以专家为出发点，每个专家要么选择他要么不选择他，当所有专家都确定是否选择后，这代表一种备选的方案，但是这个方案是否可行，需要检查是否所有n个问题都得到解决，在搜索的过程中记录最少的专家数。 （2） 以问题为出发点，每个问题都可能会有若干个专家可以解决该问题，依次尝试选择每个专家，然后继续下个问题，直到所有问题被解决。 我们考虑以第（2）个角度出发，尝试如何优化和剪枝，基本思想是：对于某个问题，如果只有一个专家能解决，则该专家是必选的，这是其中一个优化策略。对于尝试对某个问题选择专家时，如果当前已选择的专家数&gt;=已记录的最少专家数-1，则表示即使选择该专家，其最终方案的专家数也不可能少于当前记录的最少专家数，因此不需要尝试选择该专家。 进一步的优化还可以这样做：在调用搜索函数前，检查每一位专家能解决的问题，如果该专家能解决的问题，另一位专家都能解决，则该专家不需要参与选择，即可以在数组中标志该专家为已选择（注意，虽然将他标志为已选择，但是该专家不计算在已选择专家数中），这样在递归搜索时其搜索的规模将会降低。 附标程（效率还是比较低）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;namespace UMR/*防作弊专用命名空间*/&#123; int a[61][7],wo[61],used[61],n,w,dec[61],ans,min;&#125;;using namespace UMR;using namespace std;void dfs(int step)&#123; bool f=true; if (step&gt;n) &#123; if (min&gt;ans) min=ans; &#125; else if (wo[step]) dfs(step+1); else if (ans&lt;min) for (int i=1; i&lt;=w; i++) if (used[i]==0) &#123; f=true; for (int j=1; j&lt;=a[i][0]; j++) if (a[i][j]==step) &#123; f=false; break; &#125; if (not f) &#123; used[i]++; ans++; for (int j=1; j&lt;=a[i][0]; j++) wo[a[i][j]]++; dfs(step+1); used[i]--; ans--; for (int j=1; j&lt;=a[i][0]; j++) wo[a[i][j]]--; &#125; &#125;&#125;int main ()&#123; scanf("%d%d",&amp;n,&amp;w); memset(a,0,sizeof(a)); memset(wo,0,sizeof(wo)); memset(used,0,sizeof(used)); memset(dec,0,sizeof(dec)); for (int i=1; i&lt;=w; i++) &#123; scanf("%d",&amp;a[i][0]); for (int j=1; j&lt;=a[i][0]; j++) &#123; scanf("%d",&amp;a[i][j]); if (dec[a[i][j]]!=-1) if (dec[a[i][j]]==0) dec[a[i][j]]=i; else dec[a[i][j]]=-1; &#125; &#125; ans=0; for (int i=1; i&lt;=n; i++) if (dec[i]!=0 &amp;&amp; dec[i]!=-1) &#123; if (used[dec[i]]==0) &#123; ans++; used[dec[i]]++; for (int j=1; j&lt;=a[dec[i]][0]; j++) wo[a[dec[i]][j]]++; &#125; &#125; min=2147483647; dfs(1); printf("%d",min); return 0;&#125; Problem C（小埋与TSF的密信）：跟普通的加密解密字符一样，只不过这道题要多做一步： 统计！根据大量的英文文章字母统计，绝大部分的文章中字母”e”,”E”出现得最多，因此可以在此入手。 先将输入的加密后的字符进行统计，找出出现得最多的字母，根据这个字母与”e”,”E”的关系，即可按照正常的思路进行解密。 附标程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; char in,str[100000]; long long a=1,max=0,ji=0; int zm[256]=&#123;0&#125;; while((in=getchar())!=EOF) &#123; a++; str[a]=in; if(in&lt;='Z'&amp;&amp;in&gt;='A') &#123; zm[in-65]++; &#125; if(in&gt;='a'&amp;&amp;in&lt;='z') &#123; zm[in-97]++; &#125; &#125; for(int t=0;t&lt;=26;t++) &#123; if(zm[t]&gt;zm[max]) &#123; max=t; &#125; &#125; ji=max+65-'E'; for(int t=2;t&lt;=a;t++) &#123; if(str[t]&gt;='A'&amp;&amp;str[t]&lt;='Z') &#123; if(str[t]-ji&lt;'A') &#123; cout&lt;&lt;(char)(str[t]+26-ji); &#125; else &#123; if(str[t]-ji&gt;'Z') &#123; cout&lt;&lt;(char)(str[t]-26-ji); &#125; else &#123; cout&lt;&lt;(char)(str[t]-ji); &#125; &#125; continue; &#125; if(str[t]&gt;='a'&amp;&amp;str[t]&lt;='z') &#123; if(str[t]-ji&lt;'a') &#123; cout&lt;&lt;(char)(str[t]+26-ji); &#125; else &#123; if(str[t]-ji&gt;'z') &#123; cout&lt;&lt;(char)(str[t]-26-ji); &#125; else &#123; cout&lt;&lt;(char)(str[t]-ji); &#125; &#125; continue; &#125; cout&lt;&lt;str[t]; &#125; &#125; 比赛详见:https://www.luogu.org/contestnew/show/7846]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 AT244 【ハンバーガー(Hamburger)】]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-AT244-%E3%80%90%E3%83%8F%E3%83%B3%E3%83%90%E3%83%BC%E3%82%AC%E3%83%BC-Hamburger-%E3%80%91%2F</url>
    <content type="text"><![CDATA[很水，直接三目运算符判断，看不懂的自己了解一下三目运算符，附代码： 123456789101112131415#include&lt;iostream&gt;namespace UMR//本人专属命名空间&#123; int a,b,c,d,n;&#125;using namespace std;using namespace UMR;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;n;//输入 (n*1-a&gt;=0)?cout&lt;&lt;n*1-a&lt;&lt;&quot; &quot;:cout&lt;&lt;0&lt;&lt;&quot; &quot;;//三目运算符 (n*2-b&gt;=0)?cout&lt;&lt;n*2-b&lt;&lt;&quot; &quot;:cout&lt;&lt;0&lt;&lt;&quot; &quot;;//三目运算符 (n*3-c&gt;=0)?cout&lt;&lt;n*3-c:cout&lt;&lt;0;//三目运算符 cout&lt;&lt;endl;&#125; 题目详见:https://www.luogu.org/problem/show?pid=AT244]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P3152 【正整数序列】]]></title>
    <url>%2F2018%2F04%2F26%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P3152-%E3%80%90%E6%AD%A3%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实为什么要递归，直接整除除就好了 规律仔细观察一下，答案其实是 a/2 ans次后等于0 附上代码QWQ~ 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; long long ans=0,a,b,c; cin&gt;&gt;a; if(a==1)/*特判*/ &#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; while(a/2!=0) &#123; ans++; a=a/2; &#125; cout&lt;&lt;ans&lt;&lt;endl;/*输出*/&#125; 题目详见:https://www.luogu.org/problem/show?pid=3152]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P1421 【小玉买文具】]]></title>
    <url>%2F2018%2F03%2F07%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P1421-%E3%80%90%E5%B0%8F%E7%8E%89%E4%B9%B0%E6%96%87%E5%85%B7%E3%80%91%2F</url>
    <content type="text"><![CDATA[简洁，高效 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b=19,c,zo=0,ans=0; cin&gt;&gt;a&gt;&gt;c; zo=a*10+c; ans=zo/b; cout&lt;&lt;ans&lt;&lt;endl; &#125; 题目详见：https://www.luogu.org/problem/show?pid=1421]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
</search>
