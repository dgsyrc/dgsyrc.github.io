<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[404 Not Found：该页无法显示]]></title>
    <url>%2F2019%2F01%2F17%2F1%2F</url>
    <content type="text"><![CDATA[你访问了一个不存在的页面！]]></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷管理语录（1）]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B4%9B%E8%B0%B7%E7%AE%A1%E7%90%86%E8%AF%AD%E5%BD%95%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十校联考-九上期末考试备考记]]></title>
    <url>%2F2019%2F01%2F12%2F%E4%BA%8C%E5%8D%81%E6%A0%A1%E8%81%94%E8%80%83-%E4%B9%9D%E4%B8%8A%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Start an all-round attack on the target!开始对目标发起全面进攻！]]></content>
      <tags>
        <tag>备考</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Minecraft生存系列（1）]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%88%91%E7%9A%84Minecraft%E7%94%9F%E5%AD%98%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[存档快一个月了，想着博客刚刚更新没多久，我还是决定分享一下成果吧！（不会告诉你大部分时间是在机房FB推存档进度的） 世界时间：Day32 物品：矿物： 绿宝石*6钻石*35金锭*50萤石粉*64青金石*102铁锭*54 （我好穷啊）石英*68红石粉*561煤炭*7 （wdf）金粒*7 （猪人赠）当然数据这只是这个箱子里的，加上其他地方的也就多一点而已了 战利品： 金剑*3 （来自友好的猪人）金胸甲*2 （来自友好的猪人）金马铠*6 （地狱堡垒）铁马铠*4 （地狱堡垒）钻石马铠*1 （穿在我家白龙马上了）鞍*1 （沙漠神殿）金苹果*1 （地狱堡垒）粘液球*27 （在另一个箱子里）命名牌*2附魔书：爆炸保护Ⅲ （沙漠神殿）经验修补 （钓鱼）锋利Ⅲ （沙漠神殿）火焰保护Ⅲ 水下呼吸Ⅱ （钓鱼….）力量Ⅳ 锋利Ⅲ （钓鱼….出神装….）要致富，先钓鱼 酿药： 原料：地狱疣*107红石粉*8 （前面矿物箱还有一大把）萤石粉*43河豚*2烈焰棒*5金粒*9糖*8成品：力量药水（8:00）*3迅捷药水（8:00）*3水肺药水（8:00）*3家：基本属性：坐标：X：1424 Y：7 Z:-1430大小：不会算…挖了约64*64=4096块石头左右设施：通道： 客厅/厨房： 木有家具欸… 农场： 甘蔗小麦南瓜地狱疣牧场：牛/羊： 鸡： 马（白龙马）： 储物室： 附魔室+地狱传送门： 酿药室： 荒废的史莱姆农场： 重生点-床（地底有Bug，设不了）： 周边-岩浆湖： 进度：地狱： 地狱堡垒： 烈焰人刷怪笼： 期待下一篇生存系列报导！]]></content>
      <tags>
        <tag>Minecraft</tag>
        <tag>我的世界</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P3955 【图书管理员】]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P3955%20%E3%80%90%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E5%91%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看了下面一堆大佬的代码，感觉好麻烦，其实无需排序直接对每一次询问进行比较就好了（反正数据不大，用不上字符串）。 附代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int n,q,nl[1001],ql[1001],qsl[1001];/*n为图书馆里书的数量，q为读者的数量，nl是书的编码，ql是询问的编码，qsl是询问的编码的长度*/int main()&#123; cin&gt;&gt;n&gt;&gt;q;/*输入*/ for(int a=1;a&lt;=n;a++) &#123; cin&gt;&gt;nl[a];/*读入书的编码*/ &#125; for(int a=1;a&lt;=q;a++) &#123; int ans=-1,k=1; cin&gt;&gt;qsl[a];/*读入询问编码的长度*/ cin&gt;&gt;ql[a];/*读入询问的编码*/ for(int c=1;c&lt;=qsl[a];c++)/*处理比较的数位*/ &#123; k=k*10; &#125; for(int b=1;b&lt;=n;b++)/*逐书比较*/ &#123; if(nl[b]%k==ql[a])/*取书的编码的末qsl[a]位与询问编码比较*/ &#123; if(ans==-1||(ans&gt;nl[b]))/*判断是否未找到或是否比已找到的小*/ &#123; ans=nl[b];/*读入已知书编码最小值*/ &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;/*输出*/ &#125;&#125; 题目详见:https://www.luogu.org/problemnew/show/P3955]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UMR IT Team 团队守则]]></title>
    <url>%2F2018%2F08%2F30%2FUMR-IT-Team-%E5%9B%A2%E9%98%9F%E5%AE%88%E5%88%99%2F</url>
    <content type="text"><![CDATA[关于团队：本团队是一个和谐的信息技术交流团队 团队已加入 团队联盟 团队分组：主团：QWQ：管理员 dalao：用户 合作伙伴：合作的团队的管理员（仅限一人，团队主优先） ky：em….团队主学校的OIer Rank#1：团队比赛的NO.1（不具备管理权限） 分团：QWQ：管理员 出题团：贡献题目的用户 dalao：用户 Rank#1：团队比赛的NO.1（具备管理权限） 合作伙伴：合作的团队的管理员（仅限一人，团队主优先） 比赛：1.团队管理可以创建比赛，题目难度不限，但不可以违反洛谷的规章制度。 2.团队管理创建的比赛的比赛时间最多1个月。 3.除比赛创建者外，任何成员不得修改比赛，造成的后果小则进行警告，大则免去其管理权限或踢出团队。 4.奖励制度： 比赛结束后第一的直接升为管理员权限（分团），并分组到 Rank#1 组 题目：1.团队管理可以直接创建题目，题目难度不限，但不可以违反洛谷的规章制度。 2.除题目创建者外，任何成员不得不经创建者允许修改题目，造成的后果小则进行警告，大则免去其管理权限或踢出团队。 3.若有用户想为团队提供题目的，请找管理员，并由管理员审核和上传题目。 管理员：1.管理员分两类：分团和主团，团队中权限最大的是QWQ类管理员，主团中只允许有QWQ分类的管理员（目前不开通新管理的招聘）。 2.管理员不得授权其他成员管理权限，一经发现，没收其管理权限并不得在升为管理。 合作伙伴：概述：1.合作伙伴经管理员认证的可获得管理资格（分团）。 2.合作伙伴必须严守管理员规则，否则T出团队。 3.合作伙伴不得在在其他团队乱打团队广告，骚扰他人，严重者撤销其管理权限并取消合作。 审核条件：1.仅限团队主申请。 2.团队需30人以上。 3.题目储存需有5道及以上。 4.该团队成员至少有6人以上加入本团队。 5.一名团队主只可申请合作一次。 6.不接受有违规纪录的团队的申请。 2018-08-03 UMR IT Team 管理团]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Blog的更新]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%85%B3%E4%BA%8EBlog%E7%9A%84%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[打了一下午的代码，主要就是美化了页面，把头部和尾部改成了各用了一个内联框架，使用了公共头部与尾部，方便以后对头部和尾部的修改，然后顺便将原来左侧的按钮改到了头部，至于头部的About吧，到时候会链接到一篇关于博客功能与意义的文章，不会像现在一样链接到主页了，顺便还要感谢洛谷的某位童鞋，帮我解决了网页去白框的问题（加了一句 margin: 0px!important），这样博客的主体及基本完工了。 美化前后对比： 主页： 文章目录： 文章： 团队：]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用github搭建一个个人图床]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[相信很多洛谷的伙伴们都很喜欢发图，发图最重要的是图床。 但是，现在我要介绍的是一种无水印原图的图床，我们要借助github这个平台来搭。 github的好处在于它会给每个用户分配一个域名，域名的分配规则是： 你的github用户名.github.io 注意：用户名尽量用英文。 翻译： repositories 存储库 1.在github上注册一个账号后点击右上角的Your repositories: 2.进入repositories界面后点击new创建一个新的存储库，建议存储库命名为：你的github用户名.github.io（如果你已经使用了该存储库那就可以自定义，但是后面的图片链接会有一点不同） 3.创建成功后，先建立一个README文件 4.随后点击上方的Setting并往下拉，去到GitHub Pages设置项，把Source项设定为master branch（如若已设定好则不必改动） 5.最后就可以到存储库里存图了，上传会有几率失败，要多试几次 6.上传完成后即可到你的https://yourgithubname.github.io/你的图片名（加后缀名） 来查看图片了，可以将本链接作为图片链接用到Markdown上。（如果开始你的存储库名是你自定义的，就要把链接改成https://yourgithubname.github.io/存储库名/你的图片名（加后缀名）） 当然，github也是可以搭建网站的。]]></content>
      <tags>
        <tag>图床</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干物妹！小埋！第三弹 比赛题解]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%B9%B2%E7%89%A9%E5%A6%B9%EF%BC%81%E5%B0%8F%E5%9F%8B%EF%BC%81%E7%AC%AC%E4%B8%89%E5%BC%B9-%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Problem A（小埋与NOIP）：此题其实是计算加权平均数，模拟公式过程再输出最大值即可。 $\bar{x}=\dfrac{x_1w_1+x_2w_2+…+x_nw_n}{w_1+w_2+…+w_n}$ 附标程： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; string name[6]; int lv[1000]=&#123;0&#125;,s[6][1000]=&#123;0&#125;,sco[6]=&#123;0&#125;,a,alv=0,ansm=0,anss=0; /*输入*/ cin&gt;&gt;a; for(int b=1;b&lt;=a;b++) &#123; cin&gt;&gt;lv[b]; alv=alv+lv[b]; &#125; for(int b=1;b&lt;=5;b++) &#123; int p=0; cin&gt;&gt;name[b]; /*模拟过程*/ for(int c=1;c&lt;=a;c++) &#123; cin&gt;&gt;s[b][c]; p=p+s[b][c]; &#125; sco[b]=p/alv; if(anss&lt;sco[b])/*比较*/ &#123; anss=sco[b]; ansm=b;/*最大值所在位置*/ &#125; &#125; cout&lt;&lt;name[ansm]&lt;&lt;endl;/*输出*/&#125; Problem B（小埋与数羊）：裸DP题，可以通过求从第一行出发后每个点所能得出的最大值，转移方程为：q[a][b]=max(q[a][b],q[a-1][c]+_map[a][b]); 附标程（效率还是比较低，没压缩）： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int pa,ans;int n,_map[100010][5]=&#123;0&#125;,q[100010][5]=&#123;0&#125;;int main()&#123; cin&gt;&gt;n; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=4;b++) &#123; cin&gt;&gt;_map[a][b]; q[a][b]=_map[a][b]; &#125; &#125; pa=0; for(int a=2;a&lt;=n;a++) &#123; for(int b=1;b&lt;=4;b++) &#123; for(int c=1;c&lt;=4;c++) &#123; if(b==c) &#123; continue; &#125; else &#123; q[a][b]=max(q[a][b],q[a-1][c]+_map[a][b]); &#125; &#125; &#125; &#125; for(int a=1;a&lt;=4;a++) &#123; ans=max(q[n][a],ans); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Problem C（小埋与二分法）：又是字符串，不过这次复杂了很多，但脑洞就没有上次的Problem C（小埋与TSF的密信）那么大，可能很多人提交之后都会怀疑数据有问题，那你就错了，其实你们题目可能漏了一点没有看，那就是： 输入数据是密文！本题的题意其实是让你按照加密过程的逆过程来解密，可能有人会连加密过程都看不懂，那我就图解一下吧： 再简单点说其实就是先序遍历转中序遍历附标程： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;char a[201000],s[201000];int k;void dg(int l,int r)/*“逆”二分*/&#123; int mid=(l+r)&gt;&gt;1;/*位运算&gt;&gt;1其实是div2*/ a[mid]=s[k]; k++; if (l&lt;mid) &#123; dg(l,mid-1); &#125; if (r&gt;mid) &#123; dg(mid+1,r); &#125;&#125;int main()&#123; k=0; scanf("%s",s);/*输入*/ int l=strlen(s)-1; dg(0,l); /*输出*/ for (int i=0;i&lt;=l;i++) &#123; printf("%c",a[i]); &#125; printf("\n");&#125; 比赛详见:https://www.luogu.org/contestnew/show/9387]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干物妹！小埋！第二弹 比赛题解]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%B9%B2%E7%89%A9%E5%A6%B9%EF%BC%81%E5%B0%8F%E5%9F%8B%EF%BC%81%E7%AC%AC%E4%BA%8C%E5%BC%B9%20%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Problem A（小埋与Chicken rabbit with cages）：此题为典型的鸡兔同笼问题，原意用于照顾蒟蒻，故比较简单，模拟解方程组即可。 $ x+y=head $ $ 2x+4y=leg $ 附标程： 12345678910111213141516171819#include&lt;iostream&gt;namespace UMR/*防抄袭命名空间*/&#123; long long a=0,b=0,x=0,y=0; int n;&#125;;using namespace std;using namespace UMR;int main()&#123; cin&gt;&gt;n; for(int d=1;d&lt;=n;d++) &#123; cin&gt;&gt;a&gt;&gt;b; y=(b-2*a)/2; x=a-y; cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; &#125;&#125; Problem B（小埋与哥哥的企划）：采用深度优先搜索（DFS）算法，可以从两个角度出发： （1） 以专家为出发点，每个专家要么选择他要么不选择他，当所有专家都确定是否选择后，这代表一种备选的方案，但是这个方案是否可行，需要检查是否所有n个问题都得到解决，在搜索的过程中记录最少的专家数。 （2） 以问题为出发点，每个问题都可能会有若干个专家可以解决该问题，依次尝试选择每个专家，然后继续下个问题，直到所有问题被解决。 我们考虑以第（2）个角度出发，尝试如何优化和剪枝，基本思想是：对于某个问题，如果只有一个专家能解决，则该专家是必选的，这是其中一个优化策略。对于尝试对某个问题选择专家时，如果当前已选择的专家数&gt;=已记录的最少专家数-1，则表示即使选择该专家，其最终方案的专家数也不可能少于当前记录的最少专家数，因此不需要尝试选择该专家。 进一步的优化还可以这样做：在调用搜索函数前，检查每一位专家能解决的问题，如果该专家能解决的问题，另一位专家都能解决，则该专家不需要参与选择，即可以在数组中标志该专家为已选择（注意，虽然将他标志为已选择，但是该专家不计算在已选择专家数中），这样在递归搜索时其搜索的规模将会降低。 附标程（效率还是比较低）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;namespace UMR/*防作弊专用命名空间*/&#123; int a[61][7],wo[61],used[61],n,w,dec[61],ans,min;&#125;;using namespace UMR;using namespace std;void dfs(int step)&#123; bool f=true; if (step&gt;n) &#123; if (min&gt;ans) min=ans; &#125; else if (wo[step]) dfs(step+1); else if (ans&lt;min) for (int i=1; i&lt;=w; i++) if (used[i]==0) &#123; f=true; for (int j=1; j&lt;=a[i][0]; j++) if (a[i][j]==step) &#123; f=false; break; &#125; if (not f) &#123; used[i]++; ans++; for (int j=1; j&lt;=a[i][0]; j++) wo[a[i][j]]++; dfs(step+1); used[i]--; ans--; for (int j=1; j&lt;=a[i][0]; j++) wo[a[i][j]]--; &#125; &#125;&#125;int main ()&#123; scanf("%d%d",&amp;n,&amp;w); memset(a,0,sizeof(a)); memset(wo,0,sizeof(wo)); memset(used,0,sizeof(used)); memset(dec,0,sizeof(dec)); for (int i=1; i&lt;=w; i++) &#123; scanf("%d",&amp;a[i][0]); for (int j=1; j&lt;=a[i][0]; j++) &#123; scanf("%d",&amp;a[i][j]); if (dec[a[i][j]]!=-1) if (dec[a[i][j]]==0) dec[a[i][j]]=i; else dec[a[i][j]]=-1; &#125; &#125; ans=0; for (int i=1; i&lt;=n; i++) if (dec[i]!=0 &amp;&amp; dec[i]!=-1) &#123; if (used[dec[i]]==0) &#123; ans++; used[dec[i]]++; for (int j=1; j&lt;=a[dec[i]][0]; j++) wo[a[dec[i]][j]]++; &#125; &#125; min=2147483647; dfs(1); printf("%d",min); return 0;&#125; Problem C（小埋与TSF的密信）：跟普通的加密解密字符一样，只不过这道题要多做一步： 统计！根据大量的英文文章字母统计，绝大部分的文章中字母”e”,”E”出现得最多，因此可以在此入手。 先将输入的加密后的字符进行统计，找出出现得最多的字母，根据这个字母与”e”,”E”的关系，即可按照正常的思路进行解密。 附标程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; char in,str[100000]; long long a=1,max=0,ji=0; int zm[256]=&#123;0&#125;; while((in=getchar())!=EOF) &#123; a++; str[a]=in; if(in&lt;='Z'&amp;&amp;in&gt;='A') &#123; zm[in-65]++; &#125; if(in&gt;='a'&amp;&amp;in&lt;='z') &#123; zm[in-97]++; &#125; &#125; for(int t=0;t&lt;=26;t++) &#123; if(zm[t]&gt;zm[max]) &#123; max=t; &#125; &#125; ji=max+65-'E'; for(int t=2;t&lt;=a;t++) &#123; if(str[t]&gt;='A'&amp;&amp;str[t]&lt;='Z') &#123; if(str[t]-ji&lt;'A') &#123; cout&lt;&lt;(char)(str[t]+26-ji); &#125; else &#123; if(str[t]-ji&gt;'Z') &#123; cout&lt;&lt;(char)(str[t]-26-ji); &#125; else &#123; cout&lt;&lt;(char)(str[t]-ji); &#125; &#125; continue; &#125; if(str[t]&gt;='a'&amp;&amp;str[t]&lt;='z') &#123; if(str[t]-ji&lt;'a') &#123; cout&lt;&lt;(char)(str[t]+26-ji); &#125; else &#123; if(str[t]-ji&gt;'z') &#123; cout&lt;&lt;(char)(str[t]-26-ji); &#125; else &#123; cout&lt;&lt;(char)(str[t]-ji); &#125; &#125; continue; &#125; cout&lt;&lt;str[t]; &#125; &#125; 比赛详见:https://www.luogu.org/contestnew/show/7846]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 AT244 【ハンバーガー(Hamburger)】]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-AT244-%E3%80%90%E3%83%8F%E3%83%B3%E3%83%90%E3%83%BC%E3%82%AC%E3%83%BC-Hamburger-%E3%80%91%2F</url>
    <content type="text"><![CDATA[很水，直接三目运算符判断，看不懂的自己了解一下三目运算符，附代码：123456789101112131415#include&lt;iostream&gt;namespace UMR//本人专属命名空间&#123; int a,b,c,d,n;&#125;using namespace std;using namespace UMR;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;n;//输入 (n*1-a&gt;=0)?cout&lt;&lt;n*1-a&lt;&lt;&quot; &quot;:cout&lt;&lt;0&lt;&lt;&quot; &quot;;//三目运算符 (n*2-b&gt;=0)?cout&lt;&lt;n*2-b&lt;&lt;&quot; &quot;:cout&lt;&lt;0&lt;&lt;&quot; &quot;;//三目运算符 (n*3-c&gt;=0)?cout&lt;&lt;n*3-c:cout&lt;&lt;0;//三目运算符 cout&lt;&lt;endl;&#125; 题目详见:https://www.luogu.org/problem/show?pid=AT244]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P3152 【正整数序列】]]></title>
    <url>%2F2018%2F04%2F26%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P3152-%E3%80%90%E6%AD%A3%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实为什么要递归，直接整除除就好了 规律仔细观察一下，答案其实是 a/2 ans次后等于0 附上代码QWQ~~~ 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; long long ans=0,a,b,c; cin&gt;&gt;a; if(a==1)/*特判*/ &#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; while(a/2!=0) &#123; ans++; a=a/2; &#125; cout&lt;&lt;ans&lt;&lt;endl;/*输出*/&#125; 题目详见:https://www.luogu.org/problem/show?pid=3152]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解 P1421 【小玉买文具】]]></title>
    <url>%2F2018%2F03%2F07%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P1421-%E3%80%90%E5%B0%8F%E7%8E%89%E4%B9%B0%E6%96%87%E5%85%B7%E3%80%91%2F</url>
    <content type="text"><![CDATA[简洁，高效1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b=19,c,zo=0,ans=0; cin&gt;&gt;a&gt;&gt;c; zo=a*10+c; ans=zo/b; cout&lt;&lt;ans&lt;&lt;endl; &#125; 题目详见：https://www.luogu.org/problem/show?pid=1421]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
